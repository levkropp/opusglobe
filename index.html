<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spherical Planet Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 10px;
            cursor: pointer;
        }
        #instructions.hidden {
            display: none;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.7);
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="ui">
        <div>Position: <span id="pos">0, 0, 0</span></div>
        <div>Latitude: <span id="lat">0</span>° Longitude: <span id="lon">0</span>°</div>
        <div>Grounded: <span id="grounded">No</span></div>
    </div>
    <div id="instructions">
        <h2>Spherical Planet Simulation</h2>
        <p><br>Click to start</p>
        <p><br>WASD - Move</p>
        <p>Space - Jump</p>
        <p>Mouse - Look around</p>
        <p>ESC - Release mouse</p>
    </div>
    <div id="crosshair"></div>

    <script type="module">
        // WebAssembly module for physics calculations
        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, // WASM header
            0x01, 0x0f, 0x03, // Type section
            0x60, 0x02, 0x7c, 0x7c, 0x01, 0x7c, // (f64, f64) -> f64
            0x60, 0x01, 0x7c, 0x01, 0x7c, // (f64) -> f64
            0x60, 0x03, 0x7c, 0x7c, 0x7c, 0x01, 0x7c, // (f64, f64, f64) -> f64
            0x03, 0x04, 0x03, 0x00, 0x01, 0x02, // Function section: 3 functions
            0x07, 0x1a, 0x03, // Export section
            0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x00, 0x00, // "length"
            0x04, 0x73, 0x71, 0x72, 0x74, 0x00, 0x01, // "sqrt"
            0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x33, 0x00, 0x02, // "length3"
            0x0a, 0x1e, 0x03, // Code section
            0x09, 0x00, 0x20, 0x00, 0x20, 0x00, 0x9c, 0x20, 0x01, 0x20, 0x01, 0x9c, 0xa0, 0x9f, 0x0b, // length
            0x05, 0x00, 0x20, 0x00, 0x9f, 0x0b, // sqrt
            0x0f, 0x00, 0x20, 0x00, 0x20, 0x00, 0xa2, 0x20, 0x01, 0x20, 0x01, 0xa2, 0xa0, 0x20, 0x02, 0x20, 0x02, 0xa2, 0xa0, 0x9f, 0x0b // length3
        ]);

        // Initialize WASM (we'll use JS for main physics due to WASM complexity)
        let wasmInstance = null;
        
        // WebGL setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        
        if (!gl) {
            alert('WebGL2 not supported!');
        }

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Shader sources
        const vertexShaderSource = `#version 300 es
            in vec3 aPosition;
            in vec3 aNormal;
            in vec3 aColor;
            
            uniform mat4 uProjection;
            uniform mat4 uView;
            uniform mat4 uModel;
            
            out vec3 vNormal;
            out vec3 vColor;
            out vec3 vPosition;
            
            void main() {
                vec4 worldPos = uModel * vec4(aPosition, 1.0);
                vPosition = worldPos.xyz;
                vNormal = mat3(uModel) * aNormal;
                vColor = aColor;
                gl_Position = uProjection * uView * worldPos;
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec3 vNormal;
            in vec3 vColor;
            in vec3 vPosition;
            
            uniform vec3 uLightDir;
            uniform vec3 uCameraPos;
            
            out vec4 fragColor;
            
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightDir);
                
                // Ambient
                float ambient = 0.3;
                
                // Diffuse
                float diff = max(dot(normal, lightDir), 0.0);
                
                // Simple lighting
                vec3 color = vColor * (ambient + diff * 0.7);
                
                // Fog based on distance
                float dist = length(vPosition - uCameraPos);
                float fog = 1.0 - clamp(dist / 500.0, 0.0, 0.8);
                color = mix(vec3(0.5, 0.7, 0.9), color, fog);
                
                fragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(gl, vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Get uniform locations
        const uniforms = {
            projection: gl.getUniformLocation(program, 'uProjection'),
            view: gl.getUniformLocation(program, 'uView'),
            model: gl.getUniformLocation(program, 'uModel'),
            lightDir: gl.getUniformLocation(program, 'uLightDir'),
            cameraPos: gl.getUniformLocation(program, 'uCameraPos')
        };

        // Get attribute locations
        const attribs = {
            position: gl.getAttribLocation(program, 'aPosition'),
            normal: gl.getAttribLocation(program, 'aNormal'),
            color: gl.getAttribLocation(program, 'aColor')
        };

        // Matrix utilities
        function mat4Perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function mat4LookAt(eye, center, up) {
            const z = normalize(subtract(eye, center));
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
            ]);
        }

        function mat4Identity() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        // Vector utilities
        function vec3(x, y, z) { return [x, y, z]; }
        function add(a, b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
        function subtract(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function scale(v, s) { return [v[0]*s, v[1]*s, v[2]*s]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function length(v) { return Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]); }
        function normalize(v) { const l = length(v); return l > 0 ? [v[0]/l, v[1]/l, v[2]/l] : [0,0,0]; }

        // Planet configuration
        const PLANET_RADIUS = 100;
        const PLAYER_HEIGHT = 2;
        const GRAVITY = 30;
        const MOVE_SPEED = 15;
        const JUMP_VELOCITY = 12;

        // Generate planet mesh with land and water
        function generatePlanet(radius, subdivisions) {
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];

            // Noise function for terrain
            function noise3D(x, y, z) {
                const n = Math.sin(x * 1.5) * Math.cos(y * 1.3) * Math.sin(z * 1.7) +
                         Math.sin(x * 3.1 + 1.2) * Math.cos(y * 2.7 + 0.8) * Math.sin(z * 2.9 + 1.5) * 0.5 +
                         Math.sin(x * 5.3 + 2.1) * Math.cos(y * 4.9 + 1.7) * Math.sin(z * 5.1 + 2.3) * 0.25;
                return n / 1.75;
            }

            function getTerrainType(x, y, z) {
                const n = noise3D(x * 0.05, y * 0.05, z * 0.05);
                return n > -0.1; // true = land, false = water
            }

            // Icosphere generation
            const t = (1 + Math.sqrt(5)) / 2;
            const icoVertices = [
                [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
                [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
                [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
            ].map(v => normalize(v));

            const icoFaces = [
                [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
            ];

            // Subdivide
            let currentVertices = [...icoVertices];
            let currentFaces = [...icoFaces];
            const midpointCache = {};

            function getMidpoint(i1, i2) {
                const key = i1 < i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                if (midpointCache[key] !== undefined) return midpointCache[key];
                const v1 = currentVertices[i1];
                const v2 = currentVertices[i2];
                const mid = normalize([(v1[0]+v2[0])/2, (v1[1]+v2[1])/2, (v1[2]+v2[2])/2]);
                currentVertices.push(mid);
                midpointCache[key] = currentVertices.length - 1;
                return midpointCache[key];
            }

            for (let i = 0; i < subdivisions; i++) {
                const newFaces = [];
                for (const face of currentFaces) {
                    const a = getMidpoint(face[0], face[1]);
                    const b = getMidpoint(face[1], face[2]);
                    const c = getMidpoint(face[2], face[0]);
                    newFaces.push([face[0], a, c]);
                    newFaces.push([face[1], b, a]);
                    newFaces.push([face[2], c, b]);
                    newFaces.push([a, b, c]);
                }
                currentFaces = newFaces;
            }

            // Build mesh
            for (const face of currentFaces) {
                const v0 = currentVertices[face[0]];
                const v1 = currentVertices[face[1]];
                const v2 = currentVertices[face[2]];
                
                // Center of face for color determination
                const center = normalize([(v0[0]+v1[0]+v2[0])/3, (v0[1]+v1[1]+v2[1])/3, (v0[2]+v1[2]+v2[2])/3]);
                const isLand = getTerrainType(center[0] * radius, center[1] * radius, center[2] * radius);
                
                // Color
                let color;
                if (isLand) {
                    // Green variations for land
                    const variation = (noise3D(center[0]*10, center[1]*10, center[2]*10) + 1) * 0.5;
                    color = [0.2 + variation * 0.15, 0.5 + variation * 0.3, 0.15 + variation * 0.1];
                } else {
                    // Blue variations for water
                    const variation = (noise3D(center[0]*5, center[1]*5, center[2]*5) + 1) * 0.5;
                    color = [0.1 + variation * 0.1, 0.3 + variation * 0.2, 0.6 + variation * 0.3];
                }

                const baseIndex = vertices.length / 3;
                
                for (const v of [v0, v1, v2]) {
                    vertices.push(v[0] * radius, v[1] * radius, v[2] * radius);
                    normals.push(v[0], v[1], v[2]);
                    colors.push(color[0], color[1], color[2]);
                }
                
                indices.push(baseIndex, baseIndex + 1, baseIndex + 2);
            }

            return {
                vertices: new Float32Array(vertices),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint32Array(indices)
            };
        }

        // Generate trees on land
        function generateTrees(radius, count) {
            const treePositions = [];
            
            // Noise function (same as planet)
            function noise3D(x, y, z) {
                const n = Math.sin(x * 1.5) * Math.cos(y * 1.3) * Math.sin(z * 1.7) +
                         Math.sin(x * 3.1 + 1.2) * Math.cos(y * 2.7 + 0.8) * Math.sin(z * 2.9 + 1.5) * 0.5 +
                         Math.sin(x * 5.3 + 2.1) * Math.cos(y * 4.9 + 1.7) * Math.sin(z * 5.1 + 2.3) * 0.25;
                return n / 1.75;
            }

            function getTerrainType(x, y, z) {
                const n = noise3D(x * 0.05, y * 0.05, z * 0.05);
                return n > -0.1; // true = land, false = water
            }
            
            // Seed random for consistent tree placement
            let seed = 12345;
            function seededRandom() {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                return seed / 0x7fffffff;
            }
            
            // Generate random points on sphere, keep only those on land
            let attempts = 0;
            while (treePositions.length < count && attempts < count * 10) {
                attempts++;
                
                // Random point on sphere using spherical coordinates
                const theta = seededRandom() * Math.PI * 2;
                const phi = Math.acos(2 * seededRandom() - 1);
                
                const x = Math.sin(phi) * Math.cos(theta);
                const y = Math.cos(phi);
                const z = Math.sin(phi) * Math.sin(theta);
                
                const pos = [x * radius, y * radius, z * radius];
                
                // Check if on land
                if (getTerrainType(pos[0], pos[1], pos[2])) {
                    // Add some variation to tree size
                    const scale = 0.7 + seededRandom() * 0.6;
                    treePositions.push({ pos: [x, y, z], scale });
                }
            }
            
            return treePositions;
        }
        
        // Create tree mesh (combined trunk + foliage for all trees)
        function createTreeMesh(treePositions, radius) {
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];
            
            const TRUNK_HEIGHT = 1.5;
            const TRUNK_RADIUS = 0.2;
            const FOLIAGE_HEIGHT = 2.5;
            const FOLIAGE_RADIUS = 1.2;
            const TRUNK_SEGMENTS = 6;
            const FOLIAGE_SEGMENTS = 8;
            
            const trunkColor = [0.4, 0.25, 0.1];
            const foliageColor = [0.1, 0.5, 0.15];
            
            for (const tree of treePositions) {
                const baseIndex = vertices.length / 3;
                const surfacePos = scale(tree.pos, radius);
                const up = tree.pos; // normalized direction from center
                const treeScale = tree.scale;
                
                // Create orthonormal basis for tree orientation
                let tempVec = Math.abs(up[1]) < 0.9 ? [0, 1, 0] : [1, 0, 0];
                const right = normalize(cross(tempVec, up));
                const forward = normalize(cross(up, right));
                
                // Helper to transform local coords to world coords
                function toWorld(localX, localY, localZ) {
                    return [
                        surfacePos[0] + (right[0] * localX + up[0] * localY + forward[0] * localZ) * treeScale,
                        surfacePos[1] + (right[1] * localX + up[1] * localY + forward[1] * localZ) * treeScale,
                        surfacePos[2] + (right[2] * localX + up[2] * localY + forward[2] * localZ) * treeScale
                    ];
                }
                
                function toWorldNormal(localX, localY, localZ) {
                    return normalize([
                        right[0] * localX + up[0] * localY + forward[0] * localZ,
                        right[1] * localX + up[1] * localY + forward[1] * localZ,
                        right[2] * localX + up[2] * localY + forward[2] * localZ
                    ]);
                }
                
                // Generate trunk (cylinder)
                const trunkBaseIdx = vertices.length / 3;
                for (let i = 0; i <= TRUNK_SEGMENTS; i++) {
                    const angle = (i / TRUNK_SEGMENTS) * Math.PI * 2;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    // Bottom vertex
                    const bottom = toWorld(cos * TRUNK_RADIUS, 0, sin * TRUNK_RADIUS);
                    const bottomNorm = toWorldNormal(cos, 0, sin);
                    vertices.push(...bottom);
                    normals.push(...bottomNorm);
                    colors.push(...trunkColor);
                    
                    // Top vertex
                    const top = toWorld(cos * TRUNK_RADIUS, TRUNK_HEIGHT, sin * TRUNK_RADIUS);
                    vertices.push(...top);
                    normals.push(...bottomNorm);
                    colors.push(...trunkColor);
                }
                
                // Trunk indices
                for (let i = 0; i < TRUNK_SEGMENTS; i++) {
                    const i0 = trunkBaseIdx + i * 2;
                    const i1 = trunkBaseIdx + i * 2 + 1;
                    const i2 = trunkBaseIdx + i * 2 + 2;
                    const i3 = trunkBaseIdx + i * 2 + 3;
                    indices.push(i0, i2, i1);
                    indices.push(i1, i2, i3);
                }
                
                // Generate foliage (cone)
                const foliageBaseIdx = vertices.length / 3;
                
                // Cone tip
                const tip = toWorld(0, TRUNK_HEIGHT + FOLIAGE_HEIGHT, 0);
                vertices.push(...tip);
                normals.push(...up);
                colors.push(...foliageColor);
                const tipIdx = foliageBaseIdx;
                
                // Cone base vertices
                for (let i = 0; i <= FOLIAGE_SEGMENTS; i++) {
                    const angle = (i / FOLIAGE_SEGMENTS) * Math.PI * 2;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    const baseVert = toWorld(cos * FOLIAGE_RADIUS, TRUNK_HEIGHT, sin * FOLIAGE_RADIUS);
                    // Cone normal points outward and up
                    const coneNorm = toWorldNormal(cos * 0.7, 0.7, sin * 0.7);
                    vertices.push(...baseVert);
                    normals.push(...coneNorm);
                    colors.push(...foliageColor);
                }
                
                // Foliage cone indices
                for (let i = 0; i < FOLIAGE_SEGMENTS; i++) {
                    const i0 = tipIdx;
                    const i1 = foliageBaseIdx + 1 + i;
                    const i2 = foliageBaseIdx + 1 + i + 1;
                    indices.push(i0, i2, i1);
                }
                
                // Cone bottom cap
                const capCenterIdx = vertices.length / 3;
                const capCenter = toWorld(0, TRUNK_HEIGHT, 0);
                const downNorm = toWorldNormal(0, -1, 0);
                vertices.push(...capCenter);
                normals.push(...downNorm);
                colors.push(...foliageColor);
                
                for (let i = 0; i < FOLIAGE_SEGMENTS; i++) {
                    const i1 = foliageBaseIdx + 1 + i;
                    const i2 = foliageBaseIdx + 1 + i + 1;
                    indices.push(capCenterIdx, i1, i2);
                }
            }
            
            return {
                vertices: new Float32Array(vertices),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint32Array(indices)
            };
        }

        // Create planet
        const planet = generatePlanet(PLANET_RADIUS, 5);
        
        // Create trees
        const treePositions = generateTrees(PLANET_RADIUS, 500);
        const treeMesh = createTreeMesh(treePositions, PLANET_RADIUS);
        
        // Create VAO
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);

        // Position buffer
        const posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, planet.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

        // Normal buffer
        const normBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, planet.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

        // Color buffer
        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, planet.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

        // Index buffer
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planet.indices, gl.STATIC_DRAW);

        // Create Tree VAO
        const treeVao = gl.createVertexArray();
        gl.bindVertexArray(treeVao);

        // Tree position buffer
        const treePosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, treePosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, treeMesh.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

        // Tree normal buffer
        const treeNormBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, treeNormBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, treeMesh.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

        // Tree color buffer
        const treeColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, treeColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, treeMesh.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

        // Tree index buffer
        const treeIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, treeIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, treeMesh.indices, gl.STATIC_DRAW);

        // Player state
        const player = {
            position: [0, PLANET_RADIUS + PLAYER_HEIGHT, 0],
            velocity: [0, 0, 0],
            // Store the player's forward direction on the sphere surface (tangent)
            // This gets updated as they move to maintain continuity
            forward: [0, 0, -1], // Initial forward direction
            pitch: 0,
            grounded: false
        };

        // Quaternion utilities for smooth rotation
        function quatFromAxisAngle(axis, angle) {
            const s = Math.sin(angle / 2);
            return [axis[0] * s, axis[1] * s, axis[2] * s, Math.cos(angle / 2)];
        }

        function quatMultiply(a, b) {
            return [
                a[3]*b[0] + a[0]*b[3] + a[1]*b[2] - a[2]*b[1],
                a[3]*b[1] - a[0]*b[2] + a[1]*b[3] + a[2]*b[0],
                a[3]*b[2] + a[0]*b[1] - a[1]*b[0] + a[2]*b[3],
                a[3]*b[3] - a[0]*b[0] - a[1]*b[1] - a[2]*b[2]
            ];
        }

        function quatRotateVector(q, v) {
            const qv = [q[0], q[1], q[2]];
            const uv = cross(qv, v);
            const uuv = cross(qv, uv);
            return [
                v[0] + 2 * (q[3] * uv[0] + uuv[0]),
                v[1] + 2 * (q[3] * uv[1] + uuv[1]),
                v[2] + 2 * (q[3] * uv[2] + uuv[2])
            ];
        }

        // Input state
        const keys = {};
        let mouseLocked = false;

        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        document.addEventListener('mousemove', e => {
            if (mouseLocked) {
                const yawDelta = -e.movementX * 0.002;
                const pitchDelta = e.movementY * 0.002;
                
                // Rotate forward vector around up axis for yaw
                const up = normalize(player.position);
                const cosYaw = Math.cos(yawDelta);
                const sinYaw = Math.sin(yawDelta);
                
                // Rodrigues rotation formula around up axis
                let forward = player.forward;
                const forwardDotUp = dot(forward, up);
                forward = subtract(forward, scale(up, forwardDotUp)); // ensure tangent
                if (length(forward) > 0.001) {
                    forward = normalize(forward);
                    const rotated = add(
                        scale(forward, cosYaw),
                        scale(cross(up, forward), sinYaw)
                    );
                    player.forward = normalize(rotated);
                }
                
                // Update pitch (this is just a viewing angle, not affecting forward)
                player.pitch += pitchDelta;
                player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch));
            }
        });

        const instructions = document.getElementById('instructions');
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === canvas;
            instructions.classList.toggle('hidden', mouseLocked);
        });

        // Physics update
        function updatePhysics(dt) {
            // Get player's "up" direction (away from planet center)
            const up = normalize(player.position);
            
            // Re-orthogonalize forward to be tangent to sphere
            // This maintains a smooth, continuous reference frame
            let forward = player.forward;
            // Remove any component of forward that points along up
            const forwardDotUp = dot(forward, up);
            forward = subtract(forward, scale(up, forwardDotUp));
            
            // If forward became degenerate, pick a new one
            if (length(forward) < 0.001) {
                // Find any vector not parallel to up
                if (Math.abs(up[1]) < 0.9) {
                    forward = [0, 1, 0];
                } else {
                    forward = [1, 0, 0];
                }
                forward = subtract(forward, scale(up, dot(forward, up)));
            }
            forward = normalize(forward);
            player.forward = forward;
            
            // Calculate right vector (forward is now the look direction directly)
            const right = normalize(cross(forward, up));
            
            // Movement input - use forward and right directly (no yaw, it's baked into forward)
            let moveDir = [0, 0, 0];
            if (keys['KeyW']) moveDir = add(moveDir, forward);
            if (keys['KeyS']) moveDir = subtract(moveDir, forward);
            if (keys['KeyD']) moveDir = add(moveDir, right);
            if (keys['KeyA']) moveDir = subtract(moveDir, right);
            
            if (length(moveDir) > 0) {
                moveDir = normalize(moveDir);
                const moveVel = scale(moveDir, MOVE_SPEED);
                // Project current velocity onto up, keep that, replace horizontal
                const verticalVel = scale(up, dot(player.velocity, up));
                player.velocity = add(verticalVel, moveVel);
            } else {
                // Dampen horizontal velocity when not moving
                const verticalVel = scale(up, dot(player.velocity, up));
                const horizontalVel = subtract(player.velocity, verticalVel);
                player.velocity = add(verticalVel, scale(horizontalVel, 0.9));
            }
            
            // Jumping
            if (keys['Space'] && player.grounded) {
                player.velocity = add(player.velocity, scale(up, JUMP_VELOCITY));
                player.grounded = false;
            }
            
            // Gravity (towards planet center)
            const gravityDir = scale(up, -1);
            player.velocity = add(player.velocity, scale(gravityDir, GRAVITY * dt));
            
            // Store old up for rotating forward vector
            const oldUp = up;
            
            // Update position
            player.position = add(player.position, scale(player.velocity, dt));
            
            // Ground collision
            const newDist = length(player.position);
            const newUp = normalize(player.position);
            
            if (newDist < PLANET_RADIUS + PLAYER_HEIGHT) {
                player.position = scale(newUp, PLANET_RADIUS + PLAYER_HEIGHT);
                // Remove velocity towards planet
                const velTowardsPlanet = dot(player.velocity, scale(newUp, -1));
                if (velTowardsPlanet > 0) {
                    player.velocity = add(player.velocity, scale(newUp, velTowardsPlanet));
                }
                player.grounded = true;
            } else {
                player.grounded = false;
            }
            
            // Rotate forward vector to stay tangent as player moves on sphere
            // Calculate rotation from oldUp to newUp
            const rotationAxis = cross(oldUp, newUp);
            const rotationAxisLen = length(rotationAxis);
            if (rotationAxisLen > 0.0001) {
                const angle = Math.asin(Math.min(1, rotationAxisLen));
                const axis = scale(rotationAxis, 1 / rotationAxisLen);
                const q = quatFromAxisAngle(axis, angle);
                player.forward = quatRotateVector(q, player.forward);
                // Re-normalize to prevent drift
                player.forward = normalize(player.forward);
            }
        }

        // Get camera matrices
        function getCameraMatrix() {
            const up = normalize(player.position);
            
            // Use the player's stored forward direction (already tangent to sphere)
            // Forward already includes yaw rotation from mouse input
            let forward = player.forward;
            // Ensure it's orthogonal to up
            forward = subtract(forward, scale(up, dot(forward, up)));
            forward = normalize(forward);
            
            // Calculate right
            const right = normalize(cross(forward, up));
            
            // Apply pitch only (yaw is already baked into forward)
            const cosPitch = Math.cos(-player.pitch);
            const sinPitch = Math.sin(-player.pitch);
            let lookForward = normalize([
                forward[0] * cosPitch + up[0] * sinPitch,
                forward[1] * cosPitch + up[1] * sinPitch,
                forward[2] * cosPitch + up[2] * sinPitch
            ]);
            
            const camUp = normalize(cross(right, lookForward));
            const target = add(player.position, lookForward);
            
            return mat4LookAt(player.position, target, camUp);
        }

        // UI elements
        const posEl = document.getElementById('pos');
        const latEl = document.getElementById('lat');
        const lonEl = document.getElementById('lon');
        const groundedEl = document.getElementById('grounded');

        // Main render loop
        let lastTime = performance.now();
        
        function render(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            // Update physics
            updatePhysics(dt);

            // Update UI
            const p = player.position;
            posEl.textContent = `${p[0].toFixed(1)}, ${p[1].toFixed(1)}, ${p[2].toFixed(1)}`;
            
            const lat = Math.asin(normalize(p)[1]) * 180 / Math.PI;
            const lon = Math.atan2(normalize(p)[0], normalize(p)[2]) * 180 / Math.PI;
            latEl.textContent = lat.toFixed(1);
            lonEl.textContent = lon.toFixed(1);
            groundedEl.textContent = player.grounded ? 'Yes' : 'No';

            // Clear
            gl.clearColor(0.5, 0.7, 0.9, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);

            // Use program
            gl.useProgram(program);

            // Set uniforms
            const projection = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 1000);
            const view = getCameraMatrix();
            const model = mat4Identity();

            gl.uniformMatrix4fv(uniforms.projection, false, projection);
            gl.uniformMatrix4fv(uniforms.view, false, view);
            gl.uniformMatrix4fv(uniforms.model, false, model);
            gl.uniform3f(uniforms.lightDir, 0.5, 1, 0.3);
            gl.uniform3fv(uniforms.cameraPos, player.position);

            // Draw planet
            gl.bindVertexArray(vao);
            gl.drawElements(gl.TRIANGLES, planet.indices.length, gl.UNSIGNED_INT, 0);

            // Draw trees
            gl.bindVertexArray(treeVao);
            gl.drawElements(gl.TRIANGLES, treeMesh.indices.length, gl.UNSIGNED_INT, 0);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
