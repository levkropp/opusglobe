<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Globe</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        canvas { display: block; }
        #labelCanvas { position: fixed; top: 0; left: 0; pointer-events: none; }
        #ui {
            position: fixed; top: 10px; left: 10px; color: white;
            font-family: monospace; font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            pointer-events: none;
        }
        #instructions {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; text-align: center;
            background: rgba(0,0,0,0.8); padding: 30px; border-radius: 10px; cursor: pointer;
        }
        #instructions.hidden { display: none; }
        #crosshair {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 24px; height: 24px; pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.8);
        }
        #crosshair::before { width: 2px; height: 24px; left: 11px; }
        #crosshair::after { width: 24px; height: 2px; top: 11px; }
        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: monospace; font-size: 18px;
            background: rgba(0,0,0,0.9); padding: 40px; border-radius: 10px;
            text-align: center; z-index: 1000;
        }
        #loading .bar { width: 300px; height: 20px; background: #333; border-radius: 10px; margin-top: 15px; }
        #loading .fill { height: 100%; background: #4a4; border-radius: 10px; width: 0%; transition: width 0.1s; }
        #hotbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 4px; z-index: 50; pointer-events: none;
        }
        .hotbar-slot {
            width: 48px; height: 48px; border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.5); border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            position: relative;
        }
        .hotbar-slot.selected { border-color: white; background: rgba(255,255,255,0.15); }
        .hotbar-slot .block-preview {
            width: 30px; height: 30px; border-radius: 3px;
        }
        .hotbar-slot .key-hint {
            position: absolute; top: 2px; left: 4px; font-size: 10px;
            color: rgba(255,255,255,0.6); font-family: monospace;
        }
        #sprintBar {
            position: fixed; bottom: 76px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 4px; background: rgba(0,0,0,0.4);
            border-radius: 2px; z-index: 50; pointer-events: none;
            transition: opacity 0.3s;
        }
        #sprintFill {
            height: 100%; background: rgba(255,255,255,0.7);
            border-radius: 2px; width: 100%; transition: background 0.2s;
        }
        #sprintFill.low { background: rgba(255,100,100,0.8); }
        #sprintFill.sprinting { background: rgba(100,200,255,0.8); }

        /* Mobile touch controls */
        .touch-controls {
            display: none; position: fixed; bottom: 0; left: 0; right: 0;
            height: 40vh; pointer-events: none; z-index: 100;
        }
        @media (max-width: 768px), (pointer: coarse) {
            .touch-controls { display: flex; }
            #instructions { display: none !important; }
            #crosshair { display: none; }
            #ui { font-size: 11px; padding: 6px; }
            #hotbar { bottom: 42vh; }
            #sprintBar { bottom: calc(42vh + 58px); }
        }
        .trackpad {
            width: 50%; height: 100%; pointer-events: auto; position: relative;
        }
        .trackpad-inner {
            position: absolute; bottom: 20px; width: 120px; height: 120px;
            border-radius: 50%; background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
        }
        .trackpad-left .trackpad-inner { left: 20px; }
        .trackpad-right .trackpad-inner { right: 20px; }
        .trackpad-thumb {
            position: absolute; width: 50px; height: 50px; border-radius: 50%;
            background: rgba(255,255,255,0.4); top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        .trackpad-label {
            position: absolute; bottom: 150px; color: rgba(255,255,255,0.5);
            font-family: sans-serif; font-size: 12px; text-transform: uppercase;
        }
        .trackpad-left .trackpad-label { left: 40px; }
        .trackpad-right .trackpad-label { right: 40px; }
        .jump-button, .break-button, .place-button {
            position: absolute; width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.4);
            pointer-events: auto; display: flex; align-items: center; justify-content: center;
            color: rgba(255,255,255,0.6); font-family: sans-serif; font-size: 11px; font-weight: bold;
        }
        .jump-button { bottom: 160px; right: 30px; }
        .break-button { bottom: 230px; right: 30px; background: rgba(255,80,80,0.2); border-color: rgba(255,80,80,0.4); }
        .place-button { bottom: 160px; right: 100px; background: rgba(80,180,80,0.2); border-color: rgba(80,180,80,0.4); }
        .jump-button:active, .break-button:active, .place-button:active { background: rgba(255,255,255,0.4); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="labelCanvas"></canvas>
    <div id="loading">
        <div>Generating world...</div>
        <div class="bar"><div class="fill" id="loadingFill"></div></div>
        <div id="loadingText" style="margin-top:8px;font-size:13px;color:#aaa;">0%</div>
    </div>
    <div id="ui">
        <div>Position: <span id="pos">0, 0, 0</span></div>
        <div>Latitude: <span id="lat">0</span>&deg; Longitude: <span id="lon">0</span>&deg;</div>
        <div>Grounded: <span id="grounded">No</span></div>
        <div>Players: <span id="playerCount">1</span></div>
        <div>Block: <span id="blockName">Grass</span></div>
    </div>
    <div id="instructions">
        <h2>Voxel Globe</h2>
        <p><br>Click to start</p>
        <p><br>WASD - Move &nbsp; Space - Jump &nbsp; Shift - Sprint</p>
        <p>Mouse - Look &nbsp; ESC - Release</p>
        <p>Left Click - Break &nbsp; Right Click - Place</p>
        <p>1-7 - Select block type</p>
    </div>
    <div id="crosshair"></div>
    <div id="sprintBar"><div id="sprintFill"></div></div>
    <div id="hotbar"></div>

    <div class="touch-controls" id="touchControls">
        <div class="trackpad trackpad-left" id="moveTrackpad">
            <span class="trackpad-label">Move</span>
            <div class="trackpad-inner"><div class="trackpad-thumb" id="moveThumb"></div></div>
        </div>
        <div class="trackpad trackpad-right" id="lookTrackpad">
            <span class="trackpad-label">Look</span>
            <div class="trackpad-inner"><div class="trackpad-thumb" id="lookThumb"></div></div>
            <div class="jump-button" id="jumpButton">JUMP</div>
            <div class="break-button" id="breakButton">DIG</div>
            <div class="place-button" id="placeButton">PUT</div>
        </div>
    </div>

    <script type="module">
        // ===== WEBGL SETUP =====
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) alert('WebGL2 not supported!');

        const labelCanvas = document.getElementById('labelCanvas');
        const ctx = labelCanvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            labelCanvas.width = window.innerWidth;
            labelCanvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // ===== SHADERS =====
        const vertexShaderSource = `#version 300 es
            in vec3 aPosition;
            in vec3 aNormal;
            in vec3 aColor;
            uniform mat4 uProjection;
            uniform mat4 uView;
            uniform mat4 uModel;
            out vec3 vNormal;
            out vec3 vColor;
            out vec3 vPosition;
            void main() {
                vec4 worldPos = uModel * vec4(aPosition, 1.0);
                vPosition = worldPos.xyz;
                vNormal = mat3(uModel) * aNormal;
                vColor = aColor;
                gl_Position = uProjection * uView * worldPos;
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;
            in vec3 vNormal;
            in vec3 vColor;
            in vec3 vPosition;
            uniform vec3 uLightDir;
            uniform vec3 uCameraPos;
            out vec4 fragColor;
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightDir);
                float ambient = 0.35;
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 color = vColor * (ambient + diff * 0.65);
                float dist = length(vPosition - uCameraPos);
                float fog = 1.0 - clamp(dist / 500.0, 0.0, 0.8);
                color = mix(vec3(0.5, 0.7, 0.9), color, fog);
                fragColor = vec4(color, 1.0);
            }
        `;

        // Highlight shader for block wireframe
        const highlightVertSource = `#version 300 es
            in vec3 aPosition;
            uniform mat4 uProjection;
            uniform mat4 uView;
            void main() {
                gl_Position = uProjection * uView * vec4(aPosition, 1.0);
            }
        `;
        const highlightFragSource = `#version 300 es
            precision highp float;
            out vec4 fragColor;
            void main() {
                fragColor = vec4(1.0, 1.0, 1.0, 0.9);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const uniforms = {
            projection: gl.getUniformLocation(program, 'uProjection'),
            view: gl.getUniformLocation(program, 'uView'),
            model: gl.getUniformLocation(program, 'uModel'),
            lightDir: gl.getUniformLocation(program, 'uLightDir'),
            cameraPos: gl.getUniformLocation(program, 'uCameraPos')
        };
        const attribs = {
            position: gl.getAttribLocation(program, 'aPosition'),
            normal: gl.getAttribLocation(program, 'aNormal'),
            color: gl.getAttribLocation(program, 'aColor')
        };

        // Highlight program
        const hlVS = createShader(gl, gl.VERTEX_SHADER, highlightVertSource);
        const hlFS = createShader(gl, gl.FRAGMENT_SHADER, highlightFragSource);
        const hlProgram = createProgram(gl, hlVS, hlFS);
        const hlUniforms = {
            projection: gl.getUniformLocation(hlProgram, 'uProjection'),
            view: gl.getUniformLocation(hlProgram, 'uView')
        };
        const hlAttribPos = gl.getAttribLocation(hlProgram, 'aPosition');

        // ===== MATH UTILITIES =====
        function mat4Perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
        }
        function mat4LookAt(eye, center, up) {
            const z = normalize(subtract(eye, center));
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,eye),-dot(y,eye),-dot(z,eye),1]);
        }
        function mat4Identity() { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
        function mat4Translate(x,y,z) { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]); }
        function mat4Scale(s) { return new Float32Array([s,0,0,0, 0,s,0,0, 0,0,s,0, 0,0,0,1]); }
        function mat4Multiply(a, b) {
            const r = new Float32Array(16);
            for (let i = 0; i < 4; i++)
                for (let j = 0; j < 4; j++)
                    r[j*4+i] = a[i]*b[j*4] + a[i+4]*b[j*4+1] + a[i+8]*b[j*4+2] + a[i+12]*b[j*4+3];
            return r;
        }

        function vec3(x,y,z) { return [x,y,z]; }
        function add(a,b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
        function subtract(a,b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function scale(v,s) { return [v[0]*s, v[1]*s, v[2]*s]; }
        function dot(a,b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
        function cross(a,b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function length(v) { return Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]); }
        function normalize(v) { const l = length(v); return l > 0 ? [v[0]/l, v[1]/l, v[2]/l] : [0,0,0]; }

        // ===== CONFIGURATION =====
        // Cube-sphere: R=214, N=168, h=2.0 → cell side = Rπ/(2N) ≈ 2.001 → near-perfect cubes
        const PLANET_RADIUS = 214;
        const GRAVITY = 55;
        const MOVE_SPEED = 7.5;
        const SPRINT_SPEED = 15;
        const JUMP_VELOCITY = 17;
        const GRID_N = 168; // cells per cube face edge
        const NUM_LAYERS = 15;
        const SURFACE_LAYER = 7;
        const BLOCK_HEIGHT = 2.0;
        const INNER_RADIUS = PLANET_RADIUS - SURFACE_LAYER * BLOCK_HEIGHT; // 200
        const PLAYER_HEIGHT = 1.8 * BLOCK_HEIGHT; // 3.6 total collision height
        const PLAYER_EYE_HEIGHT = 1.62 * BLOCK_HEIGHT; // 3.24 camera offset from feet
        const CHUNK_N = 24; // cells per chunk edge
        const CHUNKS_PER_EDGE = GRID_N / CHUNK_N; // 7
        const CHUNKS_PER_FACE = CHUNKS_PER_EDGE * CHUNKS_PER_EDGE; // 49
        const TOTAL_CHUNKS = 6 * CHUNKS_PER_FACE; // 294
        const TOTAL_CELLS = 6 * GRID_N * GRID_N; // 169,344
        const VIEW_ANGLE_COS = Math.cos(Math.PI / 3); // 60 degrees

        // Block types
        const BLOCK_AIR = 0;
        const BLOCK_GRASS = 1;
        const BLOCK_DIRT = 2;
        const BLOCK_STONE = 3;
        const BLOCK_WATER = 4;
        const BLOCK_SAND = 5;
        const BLOCK_WOOD = 6;
        const BLOCK_LEAVES = 7;
        const BLOCK_ICE = 8;

        const BLOCK_NAMES = ['Air', 'Grass', 'Dirt', 'Stone', 'Water', 'Sand', 'Wood', 'Leaves', 'Ice'];
        const BLOCK_COLORS = [
            [0,0,0],             // air (unused)
            [0.3, 0.7, 0.2],    // grass top
            [0.55, 0.35, 0.2],  // dirt
            [0.5, 0.5, 0.5],    // stone
            [0.2, 0.4, 0.8],    // water
            [0.9, 0.85, 0.6],   // sand
            [0.45, 0.28, 0.12], // wood
            [0.15, 0.55, 0.15], // leaves
            [0.7, 0.85, 0.95],  // ice
        ];
        // Grass side color (dirt-like)
        const GRASS_SIDE_COLOR = [0.5, 0.38, 0.22];

        // ===== CUBE-SPHERE TOPOLOGY =====
        function buildCubeSphereTopology() {
            // Face mappings: (u,v) -> (x,y,z) on cube, then normalize to sphere
            // CCW winding from outside for each face
            const FACE_MAPS = [
                (u, v) => [1, v, -u],    // Face 0: +X
                (u, v) => [-1, v, u],    // Face 1: -X
                (u, v) => [u, 1, -v],    // Face 2: +Y
                (u, v) => [u, -1, v],    // Face 3: -Y
                (u, v) => [u, v, 1],     // Face 4: +Z
                (u, v) => [-u, v, -1],   // Face 5: -Z
            ];

            // Tan-mapped grid coordinates for uniform cell sizes
            const N = GRID_N;
            const tanVals = new Float64Array(N + 1);
            for (let k = 0; k <= N; k++) {
                tanVals[k] = Math.tan(Math.PI / 4 * (2 * k / N - 1));
            }

            // Generate vertices per face: 6 × (N+1)² vertices
            const vertsPerFace = (N + 1) * (N + 1);
            const totalVerts = 6 * vertsPerFace;
            const vertices = new Array(totalVerts);

            for (let face = 0; face < 6; face++) {
                const mapFn = FACE_MAPS[face];
                for (let jv = 0; jv <= N; jv++) {
                    const v = tanVals[jv];
                    for (let iv = 0; iv <= N; iv++) {
                        const u = tanVals[iv];
                        const raw = mapFn(u, v);
                        const len = Math.sqrt(raw[0]*raw[0] + raw[1]*raw[1] + raw[2]*raw[2]);
                        const vidx = face * vertsPerFace + jv * (N + 1) + iv;
                        vertices[vidx] = [raw[0]/len, raw[1]/len, raw[2]/len];
                    }
                }
            }

            // Face (cell) array: 4 vertex indices per quad cell
            const faceCount = TOTAL_CELLS;
            const faceArray = new Uint32Array(faceCount * 4);

            for (let face = 0; face < 6; face++) {
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const cellIdx = face * N * N + j * N + i;
                        const bv = face * vertsPerFace + j * (N + 1) + i;
                        // CCW from outside: v0(i,j), v1(i+1,j), v2(i+1,j+1), v3(i,j+1)
                        faceArray[cellIdx * 4]     = bv;
                        faceArray[cellIdx * 4 + 1] = bv + 1;
                        faceArray[cellIdx * 4 + 2] = bv + (N + 1) + 1;
                        faceArray[cellIdx * 4 + 3] = bv + (N + 1);
                    }
                }
            }

            // Face centers: average of 4 vertices, normalized
            const faceCenters = new Float64Array(faceCount * 3);
            for (let idx = 0; idx < faceCount; idx++) {
                const v0 = vertices[faceArray[idx*4]];
                const v1 = vertices[faceArray[idx*4+1]];
                const v2 = vertices[faceArray[idx*4+2]];
                const v3 = vertices[faceArray[idx*4+3]];
                let cx = (v0[0]+v1[0]+v2[0]+v3[0])/4;
                let cy = (v0[1]+v1[1]+v2[1]+v3[1])/4;
                let cz = (v0[2]+v1[2]+v2[2]+v3[2])/4;
                const cl = Math.sqrt(cx*cx + cy*cy + cz*cz);
                faceCenters[idx*3] = cx/cl;
                faceCenters[idx*3+1] = cy/cl;
                faceCenters[idx*3+2] = cz/cl;
            }

            // Analytical face adjacency: 4 neighbors per cell
            // Cross-face adjacency table: [neighborFace, ai, bi, ci, aj, bj, cj]
            // neighbor i = ai*i + bi*j + ci, neighbor j = aj*i + bj*j + cj
            const M = N - 1;
            const CROSS_ADJ = [
                /* Face 0 (+X) */ [
                    [3, 0,0,M, -1,0,M],  // edge 0 (-j)
                    [5, 0,0,0,  0,1,0],  // edge 1 (+i)
                    [2, 0,0,M,  1,0,0],  // edge 2 (+j)
                    [4, 0,0,M,  0,1,0],  // edge 3 (-i)
                ],
                /* Face 1 (-X) */ [
                    [3, 0,0,0,  1,0,0],  // edge 0 (-j)
                    [4, 0,0,0,  0,1,0],  // edge 1 (+i)
                    [2, 0,0,0, -1,0,M],  // edge 2 (+j)
                    [5, 0,0,M,  0,1,0],  // edge 3 (-i)
                ],
                /* Face 2 (+Y) */ [
                    [4, 1,0,0,  0,0,M],  // edge 0 (-j)
                    [0, 0,1,0,  0,0,M],  // edge 1 (+i)
                    [5,-1,0,M,  0,0,M],  // edge 2 (+j)
                    [1, 0,-1,M, 0,0,M],  // edge 3 (-i)
                ],
                /* Face 3 (-Y) */ [
                    [5,-1,0,M,  0,0,0],  // edge 0 (-j)
                    [0, 0,-1,M, 0,0,0],  // edge 1 (+i)
                    [4, 1,0,0,  0,0,0],  // edge 2 (+j)
                    [1, 0,1,0,  0,0,0],  // edge 3 (-i)
                ],
                /* Face 4 (+Z) */ [
                    [3, 1,0,0,  0,0,M],  // edge 0 (-j)
                    [0, 0,0,0,  0,1,0],  // edge 1 (+i)
                    [2, 1,0,0,  0,0,0],  // edge 2 (+j)
                    [1, 0,0,M,  0,1,0],  // edge 3 (-i)
                ],
                /* Face 5 (-Z) */ [
                    [3,-1,0,M,  0,0,0],  // edge 0 (-j)
                    [1, 0,0,0,  0,1,0],  // edge 1 (+i)
                    [2,-1,0,M,  0,0,M],  // edge 2 (+j)
                    [0, 0,0,M,  0,1,0],  // edge 3 (-i)
                ],
            ];

            const faceNeighbors = new Int32Array(faceCount * 4).fill(-1);
            for (let f = 0; f < 6; f++) {
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const cellIdx = f * N * N + j * N + i;
                        // 4 edges: 0=bottom(-j), 1=right(+i), 2=top(+j), 3=left(-i)
                        const nbrs = [[i, j-1], [i+1, j], [i, j+1], [i-1, j]];
                        for (let e = 0; e < 4; e++) {
                            let ni = nbrs[e][0], nj = nbrs[e][1], nf = f;
                            if (ni < 0 || ni >= N || nj < 0 || nj >= N) {
                                const adj = CROSS_ADJ[f][e];
                                nf = adj[0];
                                ni = adj[1]*i + adj[2]*j + adj[3];
                                nj = adj[4]*i + adj[5]*j + adj[6];
                            }
                            faceNeighbors[cellIdx * 4 + e] = nf * N * N + nj * N + ni;
                        }
                    }
                }
            }

            // Chunk assignment: grid-based
            const chunkCount = TOTAL_CHUNKS;
            const faceToChunk = new Uint16Array(faceCount);
            const chunkFaceLists = new Array(chunkCount);
            for (let c = 0; c < chunkCount; c++) chunkFaceLists[c] = [];

            for (let f = 0; f < 6; f++) {
                for (let j = 0; j < N; j++) {
                    for (let i = 0; i < N; i++) {
                        const cellIdx = f * N * N + j * N + i;
                        const ci = Math.floor(i / CHUNK_N);
                        const cj = Math.floor(j / CHUNK_N);
                        const chunkIdx = f * CHUNKS_PER_FACE + cj * CHUNKS_PER_EDGE + ci;
                        faceToChunk[cellIdx] = chunkIdx;
                        chunkFaceLists[chunkIdx].push(cellIdx);
                    }
                }
            }

            const chunkFaces = new Array(chunkCount);
            const chunkCenters = new Float64Array(chunkCount * 3);
            for (let c = 0; c < chunkCount; c++) {
                chunkFaces[c] = new Uint32Array(chunkFaceLists[c]);
                let cx = 0, cy = 0, cz = 0;
                for (const fi of chunkFaceLists[c]) {
                    cx += faceCenters[fi*3];
                    cy += faceCenters[fi*3+1];
                    cz += faceCenters[fi*3+2];
                }
                const cl = Math.sqrt(cx*cx + cy*cy + cz*cz);
                chunkCenters[c*3] = cx/cl;
                chunkCenters[c*3+1] = cy/cl;
                chunkCenters[c*3+2] = cz/cl;
            }

            return {
                vertices, faceArray, faceCount,
                faceCenters, faceNeighbors,
                faceToChunk, chunkFaces, chunkCenters, chunkCount,
            };
        }

        // ===== FACE LOOKUP (O(1) cube-sphere projection) =====
        function buildFaceLookup() {
            const N = GRID_N;
            const invPiOver4 = 4 / Math.PI;
            const halfN = N / 2;

            return function findClosestFace(dir) {
                const ax = Math.abs(dir[0]), ay = Math.abs(dir[1]), az = Math.abs(dir[2]);
                let face, u, v;

                if (ax >= ay && ax >= az) {
                    if (dir[0] > 0) {
                        face = 0; u = -dir[2]/ax; v = dir[1]/ax;
                    } else {
                        face = 1; u = dir[2]/ax; v = dir[1]/ax;
                    }
                } else if (ay >= ax && ay >= az) {
                    if (dir[1] > 0) {
                        face = 2; u = dir[0]/ay; v = -dir[2]/ay;
                    } else {
                        face = 3; u = dir[0]/ay; v = dir[2]/ay;
                    }
                } else {
                    if (dir[2] > 0) {
                        face = 4; u = dir[0]/az; v = dir[1]/az;
                    } else {
                        face = 5; u = -dir[0]/az; v = dir[1]/az;
                    }
                }

                let i = Math.floor((Math.atan(u) * invPiOver4 + 1) * halfN);
                let j = Math.floor((Math.atan(v) * invPiOver4 + 1) * halfN);
                if (i < 0) i = 0; else if (i >= N) i = N - 1;
                if (j < 0) j = 0; else if (j >= N) j = N - 1;

                return face * N * N + j * N + i;
            };
        }

        // ===== WORLD DATA & TERRAIN =====
        function noise3D(x, y, z) {
            const n = Math.sin(x*1.5)*Math.cos(y*1.3)*Math.sin(z*1.7) +
                      Math.sin(x*3.1+1.2)*Math.cos(y*2.7+0.8)*Math.sin(z*2.9+1.5)*0.5 +
                      Math.sin(x*5.3+2.1)*Math.cos(y*4.9+1.7)*Math.sin(z*5.1+2.3)*0.25;
            return n / 1.75;
        }

        function generateTerrain(topo, worldBlocks) {
            for (let f = 0; f < topo.faceCount; f++) {
                const cx = topo.faceCenters[f*3];
                const cy = topo.faceCenters[f*3+1];
                const cz = topo.faceCenters[f*3+2];
                const px = cx * PLANET_RADIUS;
                const py = cy * PLANET_RADIUS;
                const pz = cz * PLANET_RADIUS;

                const heightNoise = noise3D(px * 0.05, py * 0.05, pz * 0.05);
                const surfaceLayer = SURFACE_LAYER + Math.round(heightNoise * 3);
                const isLow = surfaceLayer < SURFACE_LAYER - 1;

                for (let layer = 0; layer < NUM_LAYERS; layer++) {
                    if (layer > surfaceLayer) {
                        if (isLow && layer <= SURFACE_LAYER) {
                            worldBlocks[f * NUM_LAYERS + layer] = BLOCK_WATER;
                        } else {
                            worldBlocks[f * NUM_LAYERS + layer] = BLOCK_AIR;
                        }
                    } else if (layer === surfaceLayer) {
                        worldBlocks[f * NUM_LAYERS + layer] = isLow ? BLOCK_SAND : BLOCK_GRASS;
                    } else if (layer > surfaceLayer - 3) {
                        worldBlocks[f * NUM_LAYERS + layer] = BLOCK_DIRT;
                    } else {
                        worldBlocks[f * NUM_LAYERS + layer] = BLOCK_STONE;
                    }
                }
            }

            // Cave generation: carve caves using 3D noise
            for (let f = 0; f < topo.faceCount; f++) {
                const cx = topo.faceCenters[f*3];
                const cy = topo.faceCenters[f*3+1];
                const cz = topo.faceCenters[f*3+2];

                // Find surface layer for this column
                let surfLayer = -1;
                for (let l = NUM_LAYERS - 1; l >= 0; l--) {
                    const b = worldBlocks[f * NUM_LAYERS + l];
                    if (b !== BLOCK_AIR && b !== BLOCK_WATER) { surfLayer = l; break; }
                }
                if (surfLayer < 3) continue;

                for (let layer = 1; layer <= surfLayer; layer++) {
                    const r = INNER_RADIUS + (layer + 0.5) * BLOCK_HEIGHT;
                    const px = cx * r, py = cy * r, pz = cz * r;

                    // Cave noise at different frequency/offset from terrain
                    const cave = noise3D(px * 0.06 + 500, py * 0.06 + 500, pz * 0.06 + 500);

                    // Higher threshold near surface = fewer openings
                    const depth = surfLayer - layer;
                    let threshold;
                    if (depth === 0) threshold = 0.55;
                    else if (depth === 1) threshold = 0.42;
                    else threshold = 0.32;

                    if (cave > threshold) {
                        worldBlocks[f * NUM_LAYERS + layer] = BLOCK_AIR;
                    }
                }
            }

            // Place trees
            let seed = 12345;
            function seededRandom() {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                return seed / 0x7fffffff;
            }
            let treesPlaced = 0;
            for (let f = 0; f < topo.faceCount && treesPlaced < 300; f++) {
                if (seededRandom() > 0.02) continue; // ~2% chance per face
                // Check if surface is grass and has room
                let surfLayer = -1;
                for (let l = NUM_LAYERS - 1; l >= 0; l--) {
                    if (worldBlocks[f * NUM_LAYERS + l] !== BLOCK_AIR && worldBlocks[f * NUM_LAYERS + l] !== BLOCK_WATER) {
                        surfLayer = l;
                        break;
                    }
                }
                if (surfLayer < 0 || worldBlocks[f * NUM_LAYERS + surfLayer] !== BLOCK_GRASS) continue;
                if (surfLayer + 4 >= NUM_LAYERS) continue;

                // Place trunk (2 blocks)
                worldBlocks[f * NUM_LAYERS + surfLayer + 1] = BLOCK_WOOD;
                worldBlocks[f * NUM_LAYERS + surfLayer + 2] = BLOCK_WOOD;
                // Place leaves on top
                worldBlocks[f * NUM_LAYERS + surfLayer + 3] = BLOCK_LEAVES;
                worldBlocks[f * NUM_LAYERS + surfLayer + 4] = BLOCK_LEAVES;
                treesPlaced++;
            }
        }

        function getBlock(worldBlocks, faceIdx, layer) {
            if (layer < 0 || layer >= NUM_LAYERS) return layer < 0 ? BLOCK_STONE : BLOCK_AIR;
            return worldBlocks[faceIdx * NUM_LAYERS + layer];
        }

        function setBlock(worldBlocks, faceIdx, layer, blockType) {
            if (layer < 0 || layer >= NUM_LAYERS) return;
            worldBlocks[faceIdx * NUM_LAYERS + layer] = blockType;
        }

        function layerInnerRadius(layer) { return INNER_RADIUS + layer * BLOCK_HEIGHT; }
        function layerOuterRadius(layer) { return INNER_RADIUS + (layer + 1) * BLOCK_HEIGHT; }

        function isTransparent(blockType) {
            return blockType === BLOCK_AIR || blockType === BLOCK_WATER;
        }

        // ===== CHUNK MESH BUILDER =====
        function buildChunkMesh(chunk, topo, worldBlocks) {
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];
            let vertCount = 0;

            function pushVert(pos, norm, col) {
                positions.push(pos[0], pos[1], pos[2]);
                normals.push(norm[0], norm[1], norm[2]);
                colors.push(col[0], col[1], col[2]);
                return vertCount++;
            }

            function emitTri(p0, p1, p2, norm, col) {
                const i0 = pushVert(p0, norm, col);
                const i1 = pushVert(p1, norm, col);
                const i2 = pushVert(p2, norm, col);
                indices.push(i0, i1, i2);
            }

            function emitQuad(p0, p1, p2, p3, norm, col) {
                const i0 = pushVert(p0, norm, col);
                const i1 = pushVert(p1, norm, col);
                const i2 = pushVert(p2, norm, col);
                const i3 = pushVert(p3, norm, col);
                indices.push(i0, i1, i2, i0, i2, i3);
            }

            for (const faceIdx of chunk.faceIndices) {
                // 4 vertices per quad cell
                const vi0 = topo.faceArray[faceIdx * 4];
                const vi1 = topo.faceArray[faceIdx * 4 + 1];
                const vi2 = topo.faceArray[faceIdx * 4 + 2];
                const vi3 = topo.faceArray[faceIdx * 4 + 3];
                const d0 = topo.vertices[vi0]; // (i, j)
                const d1 = topo.vertices[vi1]; // (i+1, j)
                const d2 = topo.vertices[vi2]; // (i+1, j+1)
                const d3 = topo.vertices[vi3]; // (i, j+1)

                // 4 neighbors
                const nb0 = topo.faceNeighbors[faceIdx * 4];     // edge 0: bottom (-j)
                const nb1 = topo.faceNeighbors[faceIdx * 4 + 1]; // edge 1: right (+i)
                const nb2 = topo.faceNeighbors[faceIdx * 4 + 2]; // edge 2: top (+j)
                const nb3 = topo.faceNeighbors[faceIdx * 4 + 3]; // edge 3: left (-i)

                const faceCenter = [
                    topo.faceCenters[faceIdx*3],
                    topo.faceCenters[faceIdx*3+1],
                    topo.faceCenters[faceIdx*3+2]
                ];

                for (let layer = 0; layer < NUM_LAYERS; layer++) {
                    const block = getBlock(worldBlocks, faceIdx, layer);
                    if (block === BLOCK_AIR) continue;
                    if (block === BLOCK_WATER) continue;

                    const rI = layerInnerRadius(layer);
                    const rO = layerOuterRadius(layer);

                    const topColor = (block === BLOCK_GRASS) ? BLOCK_COLORS[BLOCK_GRASS] : BLOCK_COLORS[block];
                    const sideColor = (block === BLOCK_GRASS) ? GRASS_SIDE_COLOR : BLOCK_COLORS[block];

                    // 8 corner positions (4 inner + 4 outer)
                    const p0i = scale(d0, rI), p1i = scale(d1, rI);
                    const p2i = scale(d2, rI), p3i = scale(d3, rI);
                    const p0o = scale(d0, rO), p1o = scale(d1, rO);
                    const p2o = scale(d2, rO), p3o = scale(d3, rO);

                    // Top face (outer quad) - 2 triangles
                    if (isTransparent(getBlock(worldBlocks, faceIdx, layer + 1))) {
                        emitQuad(p0o, p1o, p2o, p3o, faceCenter, topColor);
                    }

                    // Bottom face (inner quad, reversed winding)
                    if (isTransparent(getBlock(worldBlocks, faceIdx, layer - 1))) {
                        const negCenter = scale(faceCenter, -1);
                        emitQuad(p0i, p3i, p2i, p1i, negCenter, sideColor);
                    }

                    // 4 side faces: normal = outward from face center toward edge midpoint
                    // Side 0: edge v0->v1 (bottom, -j neighbor)
                    if (nb0 >= 0 && isTransparent(getBlock(worldBlocks, nb0, layer))) {
                        const em = normalize([(d0[0]+d1[0])/2,(d0[1]+d1[1])/2,(d0[2]+d1[2])/2]);
                        const sn = normalize(subtract(em, faceCenter));
                        emitQuad(p0i, p1i, p1o, p0o, sn, sideColor);
                    }

                    // Side 1: edge v1->v2 (right, +i neighbor)
                    if (nb1 >= 0 && isTransparent(getBlock(worldBlocks, nb1, layer))) {
                        const em = normalize([(d1[0]+d2[0])/2,(d1[1]+d2[1])/2,(d1[2]+d2[2])/2]);
                        const sn = normalize(subtract(em, faceCenter));
                        emitQuad(p1i, p2i, p2o, p1o, sn, sideColor);
                    }

                    // Side 2: edge v2->v3 (top, +j neighbor)
                    if (nb2 >= 0 && isTransparent(getBlock(worldBlocks, nb2, layer))) {
                        const em = normalize([(d2[0]+d3[0])/2,(d2[1]+d3[1])/2,(d2[2]+d3[2])/2]);
                        const sn = normalize(subtract(em, faceCenter));
                        emitQuad(p2i, p3i, p3o, p2o, sn, sideColor);
                    }

                    // Side 3: edge v3->v0 (left, -i neighbor)
                    if (nb3 >= 0 && isTransparent(getBlock(worldBlocks, nb3, layer))) {
                        const em = normalize([(d3[0]+d0[0])/2,(d3[1]+d0[1])/2,(d3[2]+d0[2])/2]);
                        const sn = normalize(subtract(em, faceCenter));
                        emitQuad(p3i, p0i, p0o, p3o, sn, sideColor);
                    }
                }
            }

            // Upload to GPU
            if (indices.length === 0) {
                chunk.indexCount = 0;
                chunk.dirty = false;
                return;
            }

            if (!chunk.vao) {
                chunk.vao = gl.createVertexArray();
                chunk.posBuf = gl.createBuffer();
                chunk.normBuf = gl.createBuffer();
                chunk.colorBuf = gl.createBuffer();
                chunk.idxBuf = gl.createBuffer();
            }

            gl.bindVertexArray(chunk.vao);

            gl.bindBuffer(gl.ARRAY_BUFFER, chunk.posBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(attribs.position);
            gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, chunk.normBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(attribs.normal);
            gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, chunk.colorBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(attribs.color);
            gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.idxBuf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.DYNAMIC_DRAW);

            chunk.indexCount = indices.length;
            chunk.dirty = false;
        }

        // ===== BLOCK HIGHLIGHT =====
        let hlVao = null, hlPosBuf = null, hlIdxBuf = null;
        function initHighlight() {
            hlVao = gl.createVertexArray();
            hlPosBuf = gl.createBuffer();
            hlIdxBuf = gl.createBuffer();
            gl.bindVertexArray(hlVao);
            gl.bindBuffer(gl.ARRAY_BUFFER, hlPosBuf);
            gl.enableVertexAttribArray(hlAttribPos);
            gl.vertexAttribPointer(hlAttribPos, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, hlIdxBuf);
        }

        function drawBlockHighlight(faceIdx, layer, topo, viewMat, projMat) {
            const vi0 = topo.faceArray[faceIdx * 4];
            const vi1 = topo.faceArray[faceIdx * 4 + 1];
            const vi2 = topo.faceArray[faceIdx * 4 + 2];
            const vi3 = topo.faceArray[faceIdx * 4 + 3];
            const d0 = topo.vertices[vi0];
            const d1 = topo.vertices[vi1];
            const d2 = topo.vertices[vi2];
            const d3 = topo.vertices[vi3];
            const rI = layerInnerRadius(layer);
            const rO = layerOuterRadius(layer);

            // 8 corners slightly expanded for z-fighting avoidance
            const eps = 0.02;
            const verts = [
                ...scale(d0, rI - eps), ...scale(d1, rI - eps),
                ...scale(d2, rI - eps), ...scale(d3, rI - eps),
                ...scale(d0, rO + eps), ...scale(d1, rO + eps),
                ...scale(d2, rO + eps), ...scale(d3, rO + eps),
            ];
            const lineIndices = [
                0,1, 1,2, 2,3, 3,0,  // inner quad
                4,5, 5,6, 6,7, 7,4,  // outer quad
                0,4, 1,5, 2,6, 3,7   // vertical edges
            ];

            gl.useProgram(hlProgram);
            gl.uniformMatrix4fv(hlUniforms.projection, false, projMat);
            gl.uniformMatrix4fv(hlUniforms.view, false, viewMat);

            gl.bindVertexArray(hlVao);
            gl.bindBuffer(gl.ARRAY_BUFFER, hlPosBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, hlIdxBuf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(lineIndices), gl.DYNAMIC_DRAW);

            gl.disable(gl.DEPTH_TEST);
            gl.drawElements(gl.LINES, lineIndices.length, gl.UNSIGNED_SHORT, 0);
            gl.enable(gl.DEPTH_TEST);
        }

        // ===== RAYCASTING =====
        function raycastBlock(origin, direction, maxDist, topo, worldBlocks, findFace) {
            const STEP = 0.5;
            let lastFace = -1, lastLayer = -1;

            for (let t = 0.5; t < maxDist; t += STEP) {
                const px = origin[0] + direction[0] * t;
                const py = origin[1] + direction[1] * t;
                const pz = origin[2] + direction[2] * t;
                const dist = Math.sqrt(px*px + py*py + pz*pz);

                const layer = Math.floor((dist - INNER_RADIUS) / BLOCK_HEIGHT);
                if (layer < 0 || layer >= NUM_LAYERS) {
                    lastFace = -1; lastLayer = -1;
                    continue;
                }

                const il = 1/dist;
                const face = findFace([px*il, py*il, pz*il]);

                const block = getBlock(worldBlocks, face, layer);
                if (block !== BLOCK_AIR && block !== BLOCK_WATER) {
                    return {
                        hitFace: face, hitLayer: layer, hitBlock: block,
                        placeFace: lastFace, placeLayer: lastLayer
                    };
                }
                lastFace = face;
                lastLayer = layer;
            }
            return null;
        }

        // ===== PLAYER SPHERE (for multiplayer) =====
        function generatePlayerSphere(segments) {
            const vertices = [], normals = [], indices = [];
            for (let lat = 0; lat <= segments; lat++) {
                const theta = lat * Math.PI / segments;
                const sinT = Math.sin(theta), cosT = Math.cos(theta);
                for (let lon = 0; lon <= segments; lon++) {
                    const phi = lon * 2 * Math.PI / segments;
                    const x = Math.cos(phi)*sinT, y = cosT, z = Math.sin(phi)*sinT;
                    vertices.push(x,y,z); normals.push(x,y,z);
                }
            }
            for (let lat = 0; lat < segments; lat++)
                for (let lon = 0; lon < segments; lon++) {
                    const f = lat*(segments+1)+lon, s = f+segments+1;
                    indices.push(f,s,f+1, s,s+1,f+1);
                }
            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), indices: new Uint32Array(indices) };
        }

        const playerSphereMesh = generatePlayerSphere(12);

        // Player sphere VAO
        const playerSphereVao = gl.createVertexArray();
        gl.bindVertexArray(playerSphereVao);
        const psBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, psBuf);
        gl.bufferData(gl.ARRAY_BUFFER, playerSphereMesh.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);
        const psNBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, psNBuf);
        gl.bufferData(gl.ARRAY_BUFFER, playerSphereMesh.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);
        const psCBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, psCBuf);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);
        const psIBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, psIBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, playerSphereMesh.indices, gl.STATIC_DRAW);

        // Pointer mesh
        function generatePointerCylinder(radius, len, segments) {
            const vertices = [], normals = [], indices = [];
            for (let i = 0; i <= segments; i++) {
                const a = (i/segments)*Math.PI*2, c = Math.cos(a), s = Math.sin(a);
                vertices.push(c*radius,s*radius,0); normals.push(c,s,0);
                vertices.push(c*radius,s*radius,len); normals.push(c,s,0);
            }
            for (let i = 0; i < segments; i++) {
                const i0=i*2,i1=i*2+1,i2=i*2+2,i3=i*2+3;
                indices.push(i0,i2,i1, i1,i2,i3);
            }
            const ti = vertices.length/3;
            vertices.push(0,0,len+radius*2); normals.push(0,0,1);
            const fs = vertices.length/3;
            for (let i = 0; i <= segments; i++) {
                const a=(i/segments)*Math.PI*2;
                vertices.push(Math.cos(a)*radius,Math.sin(a)*radius,len);
                normals.push(Math.cos(a)*0.7,Math.sin(a)*0.7,0.7);
            }
            for (let i = 0; i < segments; i++) indices.push(ti,fs+i+1,fs+i);
            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), indices: new Uint32Array(indices) };
        }
        const pointerMesh = generatePointerCylinder(0.15, 1.2, 8);
        const pointerVao = gl.createVertexArray();
        gl.bindVertexArray(pointerVao);
        const ptPBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ptPBuf);
        gl.bufferData(gl.ARRAY_BUFFER, pointerMesh.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);
        const ptNBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ptNBuf);
        gl.bufferData(gl.ARRAY_BUFFER, pointerMesh.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);
        const ptCBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ptCBuf);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);
        const ptIBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ptIBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, pointerMesh.indices, gl.STATIC_DRAW);

        // ===== MULTIPLAYER =====
        const otherPlayers = new Map();
        let myPlayerId = null, myPlayerColor = null, ws = null;
        let pendingWorldChanges = [];
        const PLAYER_SPHERE_RADIUS = 1.0;

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}`);
            ws.onopen = () => console.log('Connected to server');
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                switch (data.type) {
                    case 'init':
                        myPlayerId = data.id;
                        myPlayerColor = data.color;
                        break;
                    case 'playerJoin':
                        otherPlayers.set(data.id, {
                            id: data.id, color: data.color,
                            position: data.position, forward: data.forward, pitch: data.pitch || 0
                        });
                        break;
                    case 'playerMove': {
                        const op = otherPlayers.get(data.id);
                        if (op) { op.position = data.position; op.forward = data.forward; op.pitch = data.pitch || 0; }
                        break;
                    }
                    case 'playerLeave':
                        otherPlayers.delete(data.id);
                        break;
                    case 'blockChange':
                        if (gameState) {
                            setBlock(gameState.worldBlocks, data.face, data.layer, data.block);
                            markChunkDirty(data.face);
                        } else {
                            pendingWorldChanges.push({ face: data.face, layer: data.layer, block: data.block });
                        }
                        break;
                    case 'worldState':
                        if (gameState && data.changes) {
                            for (const c of data.changes) {
                                setBlock(gameState.worldBlocks, c.face, c.layer, c.block);
                                markChunkDirty(c.face);
                            }
                        } else if (data.changes) {
                            pendingWorldChanges.push(...data.changes);
                        }
                        break;
                }
            };
            ws.onclose = () => setTimeout(connectWebSocket, 2000);
            ws.onerror = () => {};
        }

        let lastPositionSent = 0;
        function sendPositionUpdate(player) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const now = performance.now();
                if (now - lastPositionSent > 50) {
                    ws.send(JSON.stringify({ type: 'position', position: player.position, forward: player.forward, pitch: player.pitch }));
                    lastPositionSent = now;
                }
            }
        }
        function sendBlockChange(face, layer, block) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'blockChange', face, layer, block }));
            }
        }
        connectWebSocket();

        // ===== PLAYER STATE =====
        const player = {
            position: [0, PLANET_RADIUS + PLAYER_EYE_HEIGHT + 10, 0],
            velocity: [0, 0, 0],
            forward: [0, 0, -1],
            pitch: 0,
            grounded: false,
            sprintMeter: 100, // 0-100, drains while sprinting, regens when not
            isSprinting: false
        };

        let selectedBlockType = BLOCK_GRASS;

        // Quaternion utilities
        function quatFromAxisAngle(axis, angle) {
            const s = Math.sin(angle/2);
            return [axis[0]*s, axis[1]*s, axis[2]*s, Math.cos(angle/2)];
        }
        function quatRotateVector(q, v) {
            const qv = [q[0],q[1],q[2]];
            const uv = cross(qv,v);
            const uuv = cross(qv,uv);
            return [v[0]+2*(q[3]*uv[0]+uuv[0]), v[1]+2*(q[3]*uv[1]+uuv[1]), v[2]+2*(q[3]*uv[2]+uuv[2])];
        }

        // ===== INPUT =====
        const keys = {};
        let mouseLocked = false;

        const touchState = {
            move: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, touchId: null },
            look: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, touchId: null },
            jump: false, doBreak: false, doPlace: false
        };

        function areTouchControlsVisible() {
            const tc = document.getElementById('touchControls');
            return tc && window.getComputedStyle(tc).display !== 'none';
        }

        const moveTrackpad = document.getElementById('moveTrackpad');
        const lookTrackpad = document.getElementById('lookTrackpad');
        const moveThumb = document.getElementById('moveThumb');
        const lookThumb = document.getElementById('lookThumb');
        const jumpButton = document.getElementById('jumpButton');
        const breakButton = document.getElementById('breakButton');
        const placeButton = document.getElementById('placeButton');
        const TRACKPAD_RADIUS = 60, THUMB_MAX_OFFSET = 35;

        function updateThumbPosition(thumb, ox, oy) {
            if (!thumb) return;
            const cx = Math.max(-THUMB_MAX_OFFSET, Math.min(THUMB_MAX_OFFSET, ox));
            const cy = Math.max(-THUMB_MAX_OFFSET, Math.min(THUMB_MAX_OFFSET, oy));
            thumb.style.transform = `translate(calc(-50% + ${cx}px), calc(-50% + ${cy}px))`;
        }
        function resetThumbPosition(thumb) { if (thumb) thumb.style.transform = 'translate(-50%, -50%)'; }

        function applyLookDelta(yawDelta, pitchDelta) {
            const up = normalize(player.position);
            const cosYaw = Math.cos(yawDelta), sinYaw = Math.sin(yawDelta);
            let forward = player.forward;
            const fdu = dot(forward, up);
            forward = subtract(forward, scale(up, fdu));
            if (length(forward) > 0.001) {
                forward = normalize(forward);
                player.forward = normalize(add(scale(forward, cosYaw), scale(cross(up, forward), sinYaw)));
            }
            player.pitch += pitchDelta;
            player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch));
        }

        // Touch trackpad handlers
        if (moveTrackpad) {
            moveTrackpad.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.changedTouches[0];
                touchState.move.active = true; touchState.move.touchId = t.identifier;
                touchState.move.startX = t.clientX; touchState.move.startY = t.clientY;
                touchState.move.currentX = t.clientX; touchState.move.currentY = t.clientY;
            }, {passive:false});
            moveTrackpad.addEventListener('touchmove', e => {
                e.preventDefault();
                for (const t of e.changedTouches) if (t.identifier === touchState.move.touchId) {
                    touchState.move.currentX = t.clientX; touchState.move.currentY = t.clientY;
                    updateThumbPosition(moveThumb, touchState.move.currentX-touchState.move.startX, touchState.move.currentY-touchState.move.startY);
                }
            }, {passive:false});
            moveTrackpad.addEventListener('touchend', e => {
                for (const t of e.changedTouches) if (t.identifier === touchState.move.touchId) {
                    touchState.move.active = false; touchState.move.touchId = null; resetThumbPosition(moveThumb);
                }
            });
            moveTrackpad.addEventListener('touchcancel', () => { touchState.move.active = false; touchState.move.touchId = null; resetThumbPosition(moveThumb); });
            moveTrackpad.addEventListener('mousedown', e => {
                e.preventDefault(); touchState.move.active = true; touchState.move.touchId = 'mouse';
                touchState.move.startX = e.clientX; touchState.move.startY = e.clientY;
                touchState.move.currentX = e.clientX; touchState.move.currentY = e.clientY;
            });
        }
        if (lookTrackpad) {
            lookTrackpad.addEventListener('touchstart', e => {
                if (e.target === jumpButton || jumpButton?.contains(e.target)) return;
                if (e.target === breakButton || breakButton?.contains(e.target)) return;
                if (e.target === placeButton || placeButton?.contains(e.target)) return;
                e.preventDefault();
                const t = e.changedTouches[0];
                touchState.look.active = true; touchState.look.touchId = t.identifier;
                touchState.look.startX = t.clientX; touchState.look.startY = t.clientY;
                touchState.look.currentX = t.clientX; touchState.look.currentY = t.clientY;
            }, {passive:false});
            lookTrackpad.addEventListener('touchmove', e => {
                e.preventDefault();
                for (const t of e.changedTouches) if (t.identifier === touchState.look.touchId) {
                    const dx = t.clientX - touchState.look.currentX;
                    const dy = t.clientY - touchState.look.currentY;
                    touchState.look.currentX = t.clientX; touchState.look.currentY = t.clientY;
                    applyLookDelta(-dx*0.004, dy*0.004);
                    updateThumbPosition(lookThumb, (touchState.look.currentX-touchState.look.startX)*0.3, (touchState.look.currentY-touchState.look.startY)*0.3);
                }
            }, {passive:false});
            lookTrackpad.addEventListener('touchend', e => {
                for (const t of e.changedTouches) if (t.identifier === touchState.look.touchId) {
                    touchState.look.active = false; touchState.look.touchId = null; resetThumbPosition(lookThumb);
                }
            });
            lookTrackpad.addEventListener('touchcancel', () => { touchState.look.active = false; touchState.look.touchId = null; resetThumbPosition(lookThumb); });
            lookTrackpad.addEventListener('mousedown', e => {
                if (e.target === jumpButton || jumpButton?.contains(e.target)) return;
                e.preventDefault(); touchState.look.active = true; touchState.look.touchId = 'mouse';
                touchState.look.startX = e.clientX; touchState.look.startY = e.clientY;
                touchState.look.currentX = e.clientX; touchState.look.currentY = e.clientY;
            });
        }
        document.addEventListener('mousemove', e => {
            if (touchState.move.active && touchState.move.touchId === 'mouse') {
                touchState.move.currentX = e.clientX; touchState.move.currentY = e.clientY;
                updateThumbPosition(moveThumb, touchState.move.currentX-touchState.move.startX, touchState.move.currentY-touchState.move.startY);
            }
            if (touchState.look.active && touchState.look.touchId === 'mouse') {
                const dx = e.clientX - touchState.look.currentX, dy = e.clientY - touchState.look.currentY;
                touchState.look.currentX = e.clientX; touchState.look.currentY = e.clientY;
                applyLookDelta(-dx*0.004, dy*0.004);
                updateThumbPosition(lookThumb, (touchState.look.currentX-touchState.look.startX)*0.3, (touchState.look.currentY-touchState.look.startY)*0.3);
            }
        });
        document.addEventListener('mouseup', () => {
            if (touchState.move.touchId === 'mouse') { touchState.move.active = false; touchState.move.touchId = null; resetThumbPosition(moveThumb); }
            if (touchState.look.touchId === 'mouse') { touchState.look.active = false; touchState.look.touchId = null; resetThumbPosition(lookThumb); }
        });

        // Jump/break/place buttons
        function setupBtn(btn, prop) {
            if (!btn) return;
            btn.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); touchState[prop] = true; }, {passive:false});
            btn.addEventListener('touchend', () => touchState[prop] = false);
            btn.addEventListener('touchcancel', () => touchState[prop] = false);
            btn.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); touchState[prop] = true; });
            btn.addEventListener('mouseup', () => touchState[prop] = false);
            btn.addEventListener('mouseleave', () => touchState[prop] = false);
        }
        setupBtn(jumpButton, 'jump');
        setupBtn(breakButton, 'doBreak');
        setupBtn(placeButton, 'doPlace');

        function getMovementInput() {
            let mx = 0, my = 0;
            if (!areTouchControlsVisible()) {
                if (keys['KeyW']) my += 1; if (keys['KeyS']) my -= 1;
                if (keys['KeyD']) mx += 1; if (keys['KeyA']) mx -= 1;
            }
            if (touchState.move.active) {
                const dx = touchState.move.currentX - touchState.move.startX;
                const dy = touchState.move.currentY - touchState.move.startY;
                const dz = 10, maxD = 50;
                if (Math.abs(dx) > dz) mx += Math.max(-1, Math.min(1, (dx-Math.sign(dx)*dz)/maxD));
                if (Math.abs(dy) > dz) my -= Math.max(-1, Math.min(1, (dy-Math.sign(dy)*dz)/maxD));
            }
            return { x: Math.max(-1, Math.min(1, mx)), y: Math.max(-1, Math.min(1, my)) };
        }
        function isJumpPressed() {
            return (!areTouchControlsVisible() && keys['Space']) || touchState.jump;
        }

        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
            // Block selection 1-7
            const num = parseInt(e.key);
            if (num >= 1 && num <= 8) {
                selectedBlockType = num;
                updateHotbar();
            }
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        document.addEventListener('mousemove', e => {
            if (mouseLocked && !areTouchControlsVisible()) {
                applyLookDelta(-e.movementX * 0.002, e.movementY * 0.002);
            }
        });

        const instructions = document.getElementById('instructions');
        canvas.addEventListener('click', () => {
            if (!areTouchControlsVisible()) canvas.requestPointerLock();
        });
        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === canvas;
            instructions.classList.toggle('hidden', mouseLocked);
        });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Block break/place via mouse
        let lastBreakTime = 0, lastPlaceTime = 0;
        canvas.addEventListener('mousedown', e => {
            if (!mouseLocked || !gameState) return;
            const now = performance.now();
            if (e.button === 0 && now - lastBreakTime > 200) {
                lastBreakTime = now;
                doBreakBlock();
            } else if (e.button === 2 && now - lastPlaceTime > 200) {
                lastPlaceTime = now;
                doPlaceBlock();
            }
        });

        // ===== HOTBAR UI =====
        const hotbarEl = document.getElementById('hotbar');
        function buildHotbar() {
            hotbarEl.innerHTML = '';
            for (let i = 1; i <= 8; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (i === selectedBlockType ? ' selected' : '');
                const preview = document.createElement('div');
                preview.className = 'block-preview';
                const c = BLOCK_COLORS[i];
                preview.style.background = `rgb(${Math.floor(c[0]*255)},${Math.floor(c[1]*255)},${Math.floor(c[2]*255)})`;
                const hint = document.createElement('span');
                hint.className = 'key-hint';
                hint.textContent = i;
                slot.appendChild(hint);
                slot.appendChild(preview);
                hotbarEl.appendChild(slot);
            }
        }
        function updateHotbar() {
            const slots = hotbarEl.querySelectorAll('.hotbar-slot');
            slots.forEach((s, i) => s.classList.toggle('selected', i + 1 === selectedBlockType));
            document.getElementById('blockName').textContent = BLOCK_NAMES[selectedBlockType];
        }
        buildHotbar();

        // ===== GAME STATE (set after async init) =====
        let gameState = null;

        function markChunkDirty(faceIdx) {
            if (!gameState) return;
            const chunkIdx = gameState.topo.faceToChunk[faceIdx];
            gameState.chunks[chunkIdx].dirty = true;
            // Also dirty neighbor chunks if face is on boundary
            const topo = gameState.topo;
            for (let e = 0; e < 4; e++) {
                const nf = topo.faceNeighbors[faceIdx * 4 + e];
                if (nf >= 0) {
                    const nc = topo.faceToChunk[nf];
                    if (nc !== chunkIdx) gameState.chunks[nc].dirty = true;
                }
            }
        }

        function getLookDirection() {
            const up = normalize(player.position);
            let forward = player.forward;
            forward = subtract(forward, scale(up, dot(forward, up)));
            forward = normalize(forward);
            const cosPitch = Math.cos(-player.pitch), sinPitch = Math.sin(-player.pitch);
            return normalize([
                forward[0]*cosPitch + up[0]*sinPitch,
                forward[1]*cosPitch + up[1]*sinPitch,
                forward[2]*cosPitch + up[2]*sinPitch
            ]);
        }

        function doBreakBlock() {
            if (!gameState) return;
            const dir = getLookDirection();
            const hit = raycastBlock(player.position, dir, 20, gameState.topo, gameState.worldBlocks, gameState.findFace);
            if (hit) {
                setBlock(gameState.worldBlocks, hit.hitFace, hit.hitLayer, BLOCK_AIR);
                markChunkDirty(hit.hitFace);
                sendBlockChange(hit.hitFace, hit.hitLayer, BLOCK_AIR);
            }
        }
        function doPlaceBlock() {
            if (!gameState) return;
            const dir = getLookDirection();
            const hit = raycastBlock(player.position, dir, 20, gameState.topo, gameState.worldBlocks, gameState.findFace);
            if (hit && hit.placeFace >= 0 && hit.placeLayer >= 0) {
                // Don't place inside any player — check actual body overlap
                const blockInner = layerInnerRadius(hit.placeLayer);
                const blockOuter = layerOuterRadius(hit.placeLayer);
                function overlapsPlayer(pos) {
                    const feet = length(pos) - PLAYER_EYE_HEIGHT;
                    const head = feet + PLAYER_HEIGHT;
                    if (blockOuter > feet && blockInner < head) {
                        const face = gameState.findFace(normalize(pos));
                        if (face === hit.placeFace) return true;
                    }
                    return false;
                }
                if (overlapsPlayer(player.position)) return;
                for (const op of otherPlayers.values()) {
                    if (overlapsPlayer(op.position)) return;
                }
                setBlock(gameState.worldBlocks, hit.placeFace, hit.placeLayer, selectedBlockType);
                markChunkDirty(hit.placeFace);
                sendBlockChange(hit.placeFace, hit.placeLayer, selectedBlockType);
            }
        }

        // ===== PHYSICS =====
        function getTerrainHeight(pos, topo, worldBlocks, findFace) {
            const dir = normalize(pos);
            const face = findFace(dir);
            const dist = length(pos);
            // Scan downward from player's feet layer, not from top of world
            const feetLayer = Math.floor((dist - PLAYER_EYE_HEIGHT - INNER_RADIUS) / BLOCK_HEIGHT);
            const startLayer = Math.min(Math.max(feetLayer, 0), NUM_LAYERS - 1);
            for (let l = startLayer; l >= 0; l--) {
                const b = getBlock(worldBlocks, face, l);
                if (b !== BLOCK_AIR && b !== BLOCK_WATER) return layerOuterRadius(l);
            }
            return INNER_RADIUS;
        }

        function updatePhysics(dt) {
            if (!gameState) return;
            const up = normalize(player.position);
            let forward = player.forward;
            const fdu = dot(forward, up);
            forward = subtract(forward, scale(up, fdu));
            if (length(forward) < 0.001) {
                forward = Math.abs(up[1]) < 0.9 ? [0,1,0] : [1,0,0];
                forward = subtract(forward, scale(up, dot(forward, up)));
            }
            forward = normalize(forward);
            player.forward = forward;

            const right = normalize(cross(forward, up));
            const moveInput = getMovementInput();
            let moveDir = [0,0,0];
            if (moveInput.y !== 0) moveDir = add(moveDir, scale(forward, moveInput.y));
            if (moveInput.x !== 0) moveDir = add(moveDir, scale(right, moveInput.x));

            // Sprint: shift + moving forward + meter above 20%
            const wantsSprint = keys['ShiftLeft'] && moveInput.y > 0 && player.sprintMeter > 20;
            player.isSprinting = wantsSprint && length(moveDir) > 0;

            if (player.isSprinting) {
                // Drain: 100/6 per second = empties in 6 seconds
                player.sprintMeter = Math.max(0, player.sprintMeter - (100 / 6) * dt);
            } else {
                // Regen with S-curve: slow at extremes (<10%, >90%), fast in middle
                // Total regen time ~10 seconds from empty
                const t = player.sprintMeter / 100;
                const rate = 17 * (0.2 + 0.8 * Math.sin(t * Math.PI));
                player.sprintMeter = Math.min(100, player.sprintMeter + rate * dt);
            }

            const speed = player.isSprinting ? SPRINT_SPEED : MOVE_SPEED;

            // Check if standing on ice
            const standDir = normalize(player.position);
            const standFace = gameState.findFace(standDir);
            const feetDist = length(player.position) - PLAYER_EYE_HEIGHT;
            const standLayer = Math.floor((feetDist - INNER_RADIUS) / BLOCK_HEIGHT) - 1;
            const onIce = player.grounded && standLayer >= 0 && standLayer < NUM_LAYERS &&
                getBlock(gameState.worldBlocks, standFace, standLayer) === BLOCK_ICE;

            if (length(moveDir) > 0) {
                moveDir = normalize(moveDir);
                const verticalVel = scale(up, dot(player.velocity, up));
                if (onIce) {
                    const horizontalVel = subtract(player.velocity, verticalVel);
                    const target = scale(moveDir, speed);
                    const blended = add(scale(horizontalVel, 0.9), scale(target, 0.1));
                    player.velocity = add(verticalVel, blended);
                } else {
                    player.velocity = add(verticalVel, scale(moveDir, speed));
                }
            } else {
                const verticalVel = scale(up, dot(player.velocity, up));
                if (onIce) {
                    // Slide on ice with friction
                    const horizontalVel = subtract(player.velocity, verticalVel);
                    player.velocity = add(verticalVel, scale(horizontalVel, 0.9));
                } else {
                    // Immediately stop horizontal movement
                    player.velocity = verticalVel;
                }
            }

            if (isJumpPressed() && player.grounded) {
                player.velocity = add(player.velocity, scale(up, JUMP_VELOCITY));
                player.grounded = false;
            }

            player.velocity = add(player.velocity, scale(up, -GRAVITY * dt));

            const oldPos = [player.position[0], player.position[1], player.position[2]];
            const oldUp = up;
            player.position = add(player.position, scale(player.velocity, dt));

            let newDist = length(player.position);
            let newUp = normalize(player.position);

            // Wall collision: check if player body fits at new horizontal position
            const newGroundH = getTerrainHeight(player.position, gameState.topo, gameState.worldBlocks, gameState.findFace);
            const standEyeDist = Math.max(newDist, newGroundH + PLAYER_EYE_HEIGHT);
            const feetH = standEyeDist - PLAYER_EYE_HEIGHT;
            const bodyBot = feetH + 0.01;
            const bodyTop = feetH + PLAYER_HEIGHT - 0.01;
            const lBot = Math.floor((bodyBot - INNER_RADIUS) / BLOCK_HEIGHT);
            const lTop = Math.floor((bodyTop - INNER_RADIUS) / BLOCK_HEIGHT);
            const newFace = gameState.findFace(newUp);
            let blocked = false;
            for (let l = Math.max(0, lBot); l <= Math.min(NUM_LAYERS - 1, lTop); l++) {
                const b = getBlock(gameState.worldBlocks, newFace, l);
                if (b !== BLOCK_AIR && b !== BLOCK_WATER) { blocked = true; break; }
            }
            if (blocked) {
                // Revert horizontal movement, keep vertical change
                player.position = scale(normalize(oldPos), newDist);
                newUp = normalize(player.position);
                const vRad = dot(player.velocity, newUp);
                player.velocity = scale(newUp, vRad);
            }

            // Ground collision (at possibly reverted position)
            const groundHeight = blocked
                ? getTerrainHeight(player.position, gameState.topo, gameState.worldBlocks, gameState.findFace)
                : newGroundH;
            newDist = length(player.position);
            newUp = normalize(player.position);

            if (newDist < groundHeight + PLAYER_EYE_HEIGHT) {
                const snapUp = (groundHeight + PLAYER_EYE_HEIGHT) - newDist;
                player.position = scale(newUp, groundHeight + PLAYER_EYE_HEIGHT);
                const velDown = dot(player.velocity, scale(newUp, -1));
                if (velDown > 0) player.velocity = add(player.velocity, scale(newUp, velDown));
                // If snapped up significantly (stepped onto block), kill upward velocity to prevent super jumps
                if (snapUp > BLOCK_HEIGHT * 0.3) {
                    const velUp = dot(player.velocity, newUp);
                    if (velUp > 0) player.velocity = subtract(player.velocity, scale(newUp, velUp));
                }
                player.grounded = true;
            } else {
                player.grounded = false;
            }

            // Ceiling collision — head is above eyes by (PLAYER_HEIGHT - PLAYER_EYE_HEIGHT)
            const headClearance = PLAYER_HEIGHT - PLAYER_EYE_HEIGHT;
            const headDist = length(player.position) + headClearance;
            const headLayer = Math.floor((headDist - INNER_RADIUS) / BLOCK_HEIGHT);
            if (headLayer >= 0 && headLayer < NUM_LAYERS) {
                const curUp = normalize(player.position);
                const headFace = gameState.findFace(curUp);
                if (getBlock(gameState.worldBlocks, headFace, headLayer) !== BLOCK_AIR &&
                    getBlock(gameState.worldBlocks, headFace, headLayer) !== BLOCK_WATER) {
                    const ceilH = layerInnerRadius(headLayer) - headClearance;
                    player.position = scale(curUp, ceilH);
                    const upVel = dot(player.velocity, curUp);
                    if (upVel > 0) player.velocity = subtract(player.velocity, scale(curUp, upVel));
                }
            }

            // Rotate forward to stay tangent
            const rotAxis = cross(oldUp, newUp);
            const rotLen = length(rotAxis);
            if (rotLen > 0.0001) {
                const angle = Math.asin(Math.min(1, rotLen));
                const axis = scale(rotAxis, 1/rotLen);
                const q = quatFromAxisAngle(axis, angle);
                player.forward = normalize(quatRotateVector(q, player.forward));
            }

            // Touch break/place
            if (touchState.doBreak) { touchState.doBreak = false; doBreakBlock(); }
            if (touchState.doPlace) { touchState.doPlace = false; doPlaceBlock(); }
        }

        // ===== CAMERA =====
        function getCameraMatrix() {
            const up = normalize(player.position);
            let forward = player.forward;
            forward = subtract(forward, scale(up, dot(forward, up)));
            forward = normalize(forward);
            const right = normalize(cross(forward, up));
            const cp = Math.cos(-player.pitch), sp = Math.sin(-player.pitch);
            const lookFwd = normalize([forward[0]*cp+up[0]*sp, forward[1]*cp+up[1]*sp, forward[2]*cp+up[2]*sp]);
            const camUp = normalize(cross(right, lookFwd));
            return mat4LookAt(player.position, add(player.position, lookFwd), camUp);
        }

        // ===== MULTIPLAYER RENDERING HELPERS =====
        function createColorArray(color, count) {
            const c = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) { c[i*3] = color.r; c[i*3+1] = color.g; c[i*3+2] = color.b; }
            return c;
        }
        function mat4FromLookDirection(fwd, up) {
            const f = normalize(fwd), r = normalize(cross(f, up)), u = normalize(cross(r, f));
            return new Float32Array([r[0],r[1],r[2],0, u[0],u[1],u[2],0, f[0],f[1],f[2],0, 0,0,0,1]);
        }
        function applyPitchToForward(fwd, up, pitch) {
            const cp = Math.cos(-pitch), sp = Math.sin(-pitch);
            return normalize([fwd[0]*cp+up[0]*sp, fwd[1]*cp+up[1]*sp, fwd[2]*cp+up[2]*sp]);
        }
        function projectToScreen(wp, vm, pm) {
            let vp = [vm[0]*wp[0]+vm[4]*wp[1]+vm[8]*wp[2]+vm[12], vm[1]*wp[0]+vm[5]*wp[1]+vm[9]*wp[2]+vm[13], vm[2]*wp[0]+vm[6]*wp[1]+vm[10]*wp[2]+vm[14], vm[3]*wp[0]+vm[7]*wp[1]+vm[11]*wp[2]+vm[15]];
            let cp = [pm[0]*vp[0]+pm[4]*vp[1]+pm[8]*vp[2]+pm[12]*vp[3], pm[1]*vp[0]+pm[5]*vp[1]+pm[9]*vp[2]+pm[13]*vp[3], pm[2]*vp[0]+pm[6]*vp[1]+pm[10]*vp[2]+pm[14]*vp[3], pm[3]*vp[0]+pm[7]*vp[1]+pm[11]*vp[2]+pm[14+1]*vp[3]];
            if (cp[3] <= 0) return null;
            const nx = cp[0]/cp[3], ny = cp[1]/cp[3], nz = cp[2]/cp[3];
            if (nx<-1||nx>1||ny<-1||ny>1||nz<-1||nz>1) return null;
            return { x: (nx+1)*0.5*canvas.width, y: (1-ny)*0.5*canvas.height, depth: nz };
        }
        function drawNametag(id, sp, color) {
            const sid = id.substring(0, 8);
            ctx.font = 'bold 14px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            const tw = ctx.measureText(sid).width;
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(sp.x-tw/2-4, sp.y-20, tw+8, 18);
            ctx.fillStyle = `rgb(${Math.floor(color.r*255)},${Math.floor(color.g*255)},${Math.floor(color.b*255)})`;
            ctx.fillText(sid, sp.x, sp.y-5);
        }

        // ===== UI =====
        const posEl = document.getElementById('pos');
        const latEl = document.getElementById('lat');
        const lonEl = document.getElementById('lon');
        const groundedEl = document.getElementById('grounded');

        // ===== ASYNC INITIALIZATION =====
        async function initGame() {
            const loadingEl = document.getElementById('loading');
            const fillEl = document.getElementById('loadingFill');
            const textEl = document.getElementById('loadingText');

            textEl.textContent = 'Building topology...';
            await new Promise(r => setTimeout(r, 10));

            const topo = buildCubeSphereTopology();
            console.log(`Topology: ${topo.faceCount} faces, ${topo.chunkCount} chunks`);

            fillEl.style.width = '15%';
            textEl.textContent = 'Building face lookup...';
            await new Promise(r => setTimeout(r, 10));

            const findFace = buildFaceLookup();

            fillEl.style.width = '25%';
            textEl.textContent = 'Generating terrain...';
            await new Promise(r => setTimeout(r, 10));

            const worldBlocks = new Uint8Array(topo.faceCount * NUM_LAYERS);
            generateTerrain(topo, worldBlocks);

            fillEl.style.width = '35%';
            textEl.textContent = 'Building chunks...';
            await new Promise(r => setTimeout(r, 10));

            // Create chunks
            const chunks = new Array(topo.chunkCount);
            for (let c = 0; c < topo.chunkCount; c++) {
                chunks[c] = {
                    id: c,
                    faceIndices: topo.chunkFaces[c],
                    center: [topo.chunkCenters[c*3], topo.chunkCenters[c*3+1], topo.chunkCenters[c*3+2]],
                    dirty: true, vao: null, posBuf: null, normBuf: null, colorBuf: null, idxBuf: null, indexCount: 0
                };
            }

            // Build all chunk meshes progressively
            const batchSize = 20;
            for (let i = 0; i < chunks.length; i += batchSize) {
                for (let j = i; j < Math.min(i + batchSize, chunks.length); j++) {
                    buildChunkMesh(chunks[j], topo, worldBlocks);
                }
                const pct = 35 + (i / chunks.length) * 60;
                fillEl.style.width = pct + '%';
                textEl.textContent = `Building chunks... ${Math.min(i+batchSize, chunks.length)}/${chunks.length}`;
                await new Promise(r => setTimeout(r, 0));
            }

            // Spawn player above terrain
            const spawnDir = normalize([0, 1, 0]);
            const spawnFace = findFace(spawnDir);
            let spawnHeight = PLANET_RADIUS;
            for (let l = NUM_LAYERS - 1; l >= 0; l--) {
                if (getBlock(worldBlocks, spawnFace, l) !== BLOCK_AIR && getBlock(worldBlocks, spawnFace, l) !== BLOCK_WATER) {
                    spawnHeight = layerOuterRadius(l);
                    break;
                }
            }
            player.position = scale(spawnDir, spawnHeight + PLAYER_EYE_HEIGHT);

            initHighlight();

            fillEl.style.width = '100%';
            textEl.textContent = 'Ready!';
            await new Promise(r => setTimeout(r, 300));
            loadingEl.style.display = 'none';

            gameState = { topo, worldBlocks, findFace, chunks };

            // Apply any block changes received from server before gameState was ready
            if (pendingWorldChanges.length > 0) {
                for (const c of pendingWorldChanges) {
                    setBlock(worldBlocks, c.face, c.layer, c.block);
                    markChunkDirty(c.face);
                }
                pendingWorldChanges = [];
            }

            // Start render loop
            requestAnimationFrame(render);
        }

        // ===== RENDER LOOP =====
        let lastTime = performance.now();
        const BASE_FOV = Math.PI / 3; // 60 degrees
        const SPRINT_FOV = BASE_FOV + (20 * Math.PI / 180); // +20 degrees
        let currentFov = BASE_FOV;

        function getVisibleChunks() {
            const dir = normalize(player.position);
            const visible = [];
            for (let i = 0; i < gameState.chunks.length; i++) {
                const c = gameState.chunks[i].center;
                const d = dir[0]*c[0] + dir[1]*c[1] + dir[2]*c[2];
                if (d > VIEW_ANGLE_COS) visible.push(gameState.chunks[i]);
            }
            return visible;
        }

        function render(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            updatePhysics(dt);
            sendPositionUpdate(player);

            // Smooth FOV transition for sprint
            const targetFov = player.isSprinting ? SPRINT_FOV : BASE_FOV;
            const fovSpeed = 8; // interpolation speed
            currentFov += (targetFov - currentFov) * Math.min(1, fovSpeed * dt);

            // Rebuild dirty chunks
            let rebuilds = 0;
            for (const chunk of gameState.chunks) {
                if (chunk.dirty && rebuilds < 4) {
                    buildChunkMesh(chunk, gameState.topo, gameState.worldBlocks);
                    rebuilds++;
                }
            }

            // Update UI
            const p = player.position;
            posEl.textContent = `${p[0].toFixed(1)}, ${p[1].toFixed(1)}, ${p[2].toFixed(1)}`;
            const np = normalize(p);
            latEl.textContent = (Math.asin(np[1]) * 180 / Math.PI).toFixed(1);
            lonEl.textContent = (Math.atan2(np[0], np[2]) * 180 / Math.PI).toFixed(1);
            groundedEl.textContent = player.grounded ? 'Yes' : 'No';

            // Update sprint bar
            const sprintFill = document.getElementById('sprintFill');
            const sprintBar = document.getElementById('sprintBar');
            sprintFill.style.width = player.sprintMeter + '%';
            sprintFill.className = player.isSprinting ? 'sprinting' : (player.sprintMeter < 20 ? 'low' : '');
            sprintBar.style.opacity = player.sprintMeter < 100 || player.isSprinting ? '1' : '0';

            // Clear
            gl.clearColor(0.5, 0.7, 0.9, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            ctx.clearRect(0, 0, labelCanvas.width, labelCanvas.height);

            gl.useProgram(program);
            const projection = mat4Perspective(currentFov, canvas.width / canvas.height, 0.1, 1000);
            const view = getCameraMatrix();
            const model = mat4Identity();
            gl.uniformMatrix4fv(uniforms.projection, false, projection);
            gl.uniformMatrix4fv(uniforms.view, false, view);
            gl.uniformMatrix4fv(uniforms.model, false, model);
            gl.uniform3f(uniforms.lightDir, 0.5, 1, 0.3);
            gl.uniform3fv(uniforms.cameraPos, player.position);

            // Draw visible chunks
            const visibleChunks = getVisibleChunks();
            for (const chunk of visibleChunks) {
                if (chunk.indexCount > 0 && chunk.vao) {
                    gl.bindVertexArray(chunk.vao);
                    gl.drawElements(gl.TRIANGLES, chunk.indexCount, gl.UNSIGNED_INT, 0);
                }
            }

            // Block highlight
            const lookDir = getLookDirection();
            const hit = raycastBlock(player.position, lookDir, 20, gameState.topo, gameState.worldBlocks, gameState.findFace);
            if (hit) {
                drawBlockHighlight(hit.hitFace, hit.hitLayer, gameState.topo, view, projection);
                gl.useProgram(program); // restore program
                gl.uniformMatrix4fv(uniforms.projection, false, projection);
                gl.uniformMatrix4fv(uniforms.view, false, view);
                gl.uniformMatrix4fv(uniforms.model, false, model);
                gl.uniform3f(uniforms.lightDir, 0.5, 1, 0.3);
                gl.uniform3fv(uniforms.cameraPos, player.position);
            }

            // Draw other players
            const vertexCount = playerSphereMesh.vertices.length / 3;
            const pointerVertCount = pointerMesh.vertices.length / 3;
            otherPlayers.forEach(op => {
                const ca = createColorArray(op.color, vertexCount);
                gl.bindBuffer(gl.ARRAY_BUFFER, psCBuf);
                gl.bufferData(gl.ARRAY_BUFFER, ca, gl.DYNAMIC_DRAW);
                const pos = op.position;
                const tMat = mat4Translate(pos[0], pos[1], pos[2]);
                const sMat = mat4Scale(PLAYER_SPHERE_RADIUS);
                gl.uniformMatrix4fv(uniforms.model, false, mat4Multiply(tMat, sMat));
                gl.bindVertexArray(playerSphereVao);
                gl.drawElements(gl.TRIANGLES, playerSphereMesh.indices.length, gl.UNSIGNED_INT, 0);

                // Pointer
                const pUp = normalize(pos);
                let ld = op.forward || [0,0,-1];
                ld = subtract(ld, scale(pUp, dot(ld, pUp)));
                if (length(ld) < 0.001) ld = [0,0,-1];
                ld = normalize(ld);
                const ld3d = applyPitchToForward(ld, pUp, op.pitch || 0);
                const rm = mat4FromLookDirection(ld3d, pUp);
                const pt = mat4Translate(pos[0], pos[1], pos[2]);
                const pc = { r: op.color.r*0.7, g: op.color.g*0.7, b: op.color.b*0.7 };
                gl.bindVertexArray(pointerVao);
                gl.bindBuffer(gl.ARRAY_BUFFER, ptCBuf);
                gl.bufferData(gl.ARRAY_BUFFER, createColorArray(pc, pointerVertCount), gl.DYNAMIC_DRAW);
                gl.uniformMatrix4fv(uniforms.model, false, mat4Multiply(pt, rm));
                gl.drawElements(gl.TRIANGLES, pointerMesh.indices.length, gl.UNSIGNED_INT, 0);

                // Nametag
                const ntp = [pos[0]+pUp[0]*(PLAYER_SPHERE_RADIUS+1.5), pos[1]+pUp[1]*(PLAYER_SPHERE_RADIUS+1.5), pos[2]+pUp[2]*(PLAYER_SPHERE_RADIUS+1.5)];
                const sp = projectToScreen(ntp, view, projection);
                if (sp) drawNametag(op.id, sp, op.color);
            });

            document.getElementById('playerCount').textContent = otherPlayers.size + 1;
            gl.uniformMatrix4fv(uniforms.model, false, model);

            requestAnimationFrame(render);
        }

        // Start the game
        initGame();
    </script>
</body>
</html>
