<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spherical Planet Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            overflow: hidden;
            background: #000;
        }
        canvas {
            display: block;
        }
        #labelCanvas {
            position: fixed;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        #ui {
            position: fixed;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
        }
        #instructions {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 30px;
            border-radius: 10px;
            cursor: pointer;
        }
        #instructions.hidden {
            display: none;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255,255,255,0.7);
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="labelCanvas"></canvas>
    <div id="ui">
        <div>Position: <span id="pos">0, 0, 0</span></div>
        <div>Latitude: <span id="lat">0</span>° Longitude: <span id="lon">0</span>°</div>
        <div>Grounded: <span id="grounded">No</span></div>
        <div>Players: <span id="playerCount">1</span></div>
    </div>
    <div id="instructions">
        <h2>Spherical Planet Simulation</h2>
        <p><br>Click to start</p>
        <p><br>WASD - Move</p>
        <p>Space - Jump</p>
        <p>Mouse - Look around</p>
        <p>ESC - Release mouse</p>
    </div>
    <div id="crosshair"></div>

    <script type="module">
        // WebAssembly module for physics calculations
        const wasmCode = new Uint8Array([
            0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, // WASM header
            0x01, 0x0f, 0x03, // Type section
            0x60, 0x02, 0x7c, 0x7c, 0x01, 0x7c, // (f64, f64) -> f64
            0x60, 0x01, 0x7c, 0x01, 0x7c, // (f64) -> f64
            0x60, 0x03, 0x7c, 0x7c, 0x7c, 0x01, 0x7c, // (f64, f64, f64) -> f64
            0x03, 0x04, 0x03, 0x00, 0x01, 0x02, // Function section: 3 functions
            0x07, 0x1a, 0x03, // Export section
            0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x00, 0x00, // "length"
            0x04, 0x73, 0x71, 0x72, 0x74, 0x00, 0x01, // "sqrt"
            0x06, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68, 0x33, 0x00, 0x02, // "length3"
            0x0a, 0x1e, 0x03, // Code section
            0x09, 0x00, 0x20, 0x00, 0x20, 0x00, 0x9c, 0x20, 0x01, 0x20, 0x01, 0x9c, 0xa0, 0x9f, 0x0b, // length
            0x05, 0x00, 0x20, 0x00, 0x9f, 0x0b, // sqrt
            0x0f, 0x00, 0x20, 0x00, 0x20, 0x00, 0xa2, 0x20, 0x01, 0x20, 0x01, 0xa2, 0xa0, 0x20, 0x02, 0x20, 0x02, 0xa2, 0xa0, 0x9f, 0x0b // length3
        ]);

        // Initialize WASM (we'll use JS for main physics due to WASM complexity)
        let wasmInstance = null;
        
        // WebGL setup
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        
        if (!gl) {
            alert('WebGL2 not supported!');
        }

        // Label canvas for nametags
        const labelCanvas = document.getElementById('labelCanvas');
        const ctx = labelCanvas.getContext('2d');

        // Resize canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            labelCanvas.width = window.innerWidth;
            labelCanvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // Shader sources
        const vertexShaderSource = `#version 300 es
            in vec3 aPosition;
            in vec3 aNormal;
            in vec3 aColor;
            
            uniform mat4 uProjection;
            uniform mat4 uView;
            uniform mat4 uModel;
            
            out vec3 vNormal;
            out vec3 vColor;
            out vec3 vPosition;
            
            void main() {
                vec4 worldPos = uModel * vec4(aPosition, 1.0);
                vPosition = worldPos.xyz;
                vNormal = mat3(uModel) * aNormal;
                vColor = aColor;
                gl_Position = uProjection * uView * worldPos;
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;
            
            in vec3 vNormal;
            in vec3 vColor;
            in vec3 vPosition;
            
            uniform vec3 uLightDir;
            uniform vec3 uCameraPos;
            
            out vec4 fragColor;
            
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightDir);
                
                // Ambient
                float ambient = 0.3;
                
                // Diffuse
                float diff = max(dot(normal, lightDir), 0.0);
                
                // Simple lighting
                vec3 color = vColor * (ambient + diff * 0.7);
                
                // Fog based on distance
                float dist = length(vPosition - uCameraPos);
                float fog = 1.0 - clamp(dist / 500.0, 0.0, 0.8);
                color = mix(vec3(0.5, 0.7, 0.9), color, fog);
                
                fragColor = vec4(color, 1.0);
            }
        `;

        // Compile shader
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create program
        function createProgram(gl, vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Get uniform locations
        const uniforms = {
            projection: gl.getUniformLocation(program, 'uProjection'),
            view: gl.getUniformLocation(program, 'uView'),
            model: gl.getUniformLocation(program, 'uModel'),
            lightDir: gl.getUniformLocation(program, 'uLightDir'),
            cameraPos: gl.getUniformLocation(program, 'uCameraPos')
        };

        // Get attribute locations
        const attribs = {
            position: gl.getAttribLocation(program, 'aPosition'),
            normal: gl.getAttribLocation(program, 'aNormal'),
            color: gl.getAttribLocation(program, 'aColor')
        };

        // Matrix utilities
        function mat4Perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, 2 * far * near * nf, 0
            ]);
        }

        function mat4LookAt(eye, center, up) {
            const z = normalize(subtract(eye, center));
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([
                x[0], y[0], z[0], 0,
                x[1], y[1], z[1], 0,
                x[2], y[2], z[2], 0,
                -dot(x, eye), -dot(y, eye), -dot(z, eye), 1
            ]);
        }

        function mat4Identity() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        // Vector utilities
        function vec3(x, y, z) { return [x, y, z]; }
        function add(a, b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
        function subtract(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function scale(v, s) { return [v[0]*s, v[1]*s, v[2]*s]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function length(v) { return Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]); }
        function normalize(v) { const l = length(v); return l > 0 ? [v[0]/l, v[1]/l, v[2]/l] : [0,0,0]; }

        // Planet configuration
        const PLANET_RADIUS = 100;
        const PLAYER_HEIGHT = 2;
        const GRAVITY = 30;
        const MOVE_SPEED = 15;
        const JUMP_VELOCITY = 12;

        // Generate planet mesh with land and water
        function generatePlanet(radius, subdivisions) {
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];

            // Noise function for terrain
            function noise3D(x, y, z) {
                const n = Math.sin(x * 1.5) * Math.cos(y * 1.3) * Math.sin(z * 1.7) +
                         Math.sin(x * 3.1 + 1.2) * Math.cos(y * 2.7 + 0.8) * Math.sin(z * 2.9 + 1.5) * 0.5 +
                         Math.sin(x * 5.3 + 2.1) * Math.cos(y * 4.9 + 1.7) * Math.sin(z * 5.1 + 2.3) * 0.25;
                return n / 1.75;
            }

            function getTerrainType(x, y, z) {
                const n = noise3D(x * 0.05, y * 0.05, z * 0.05);
                return n > -0.1; // true = land, false = water
            }

            // Icosphere generation
            const t = (1 + Math.sqrt(5)) / 2;
            const icoVertices = [
                [-1, t, 0], [1, t, 0], [-1, -t, 0], [1, -t, 0],
                [0, -1, t], [0, 1, t], [0, -1, -t], [0, 1, -t],
                [t, 0, -1], [t, 0, 1], [-t, 0, -1], [-t, 0, 1]
            ].map(v => normalize(v));

            const icoFaces = [
                [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],
                [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],
                [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],
                [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]
            ];

            // Subdivide
            let currentVertices = [...icoVertices];
            let currentFaces = [...icoFaces];
            const midpointCache = {};

            function getMidpoint(i1, i2) {
                const key = i1 < i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                if (midpointCache[key] !== undefined) return midpointCache[key];
                const v1 = currentVertices[i1];
                const v2 = currentVertices[i2];
                const mid = normalize([(v1[0]+v2[0])/2, (v1[1]+v2[1])/2, (v1[2]+v2[2])/2]);
                currentVertices.push(mid);
                midpointCache[key] = currentVertices.length - 1;
                return midpointCache[key];
            }

            for (let i = 0; i < subdivisions; i++) {
                const newFaces = [];
                for (const face of currentFaces) {
                    const a = getMidpoint(face[0], face[1]);
                    const b = getMidpoint(face[1], face[2]);
                    const c = getMidpoint(face[2], face[0]);
                    newFaces.push([face[0], a, c]);
                    newFaces.push([face[1], b, a]);
                    newFaces.push([face[2], c, b]);
                    newFaces.push([a, b, c]);
                }
                currentFaces = newFaces;
            }

            // Build mesh
            for (const face of currentFaces) {
                const v0 = currentVertices[face[0]];
                const v1 = currentVertices[face[1]];
                const v2 = currentVertices[face[2]];
                
                // Center of face for color determination
                const center = normalize([(v0[0]+v1[0]+v2[0])/3, (v0[1]+v1[1]+v2[1])/3, (v0[2]+v1[2]+v2[2])/3]);
                const isLand = getTerrainType(center[0] * radius, center[1] * radius, center[2] * radius);
                
                // Color
                let color;
                if (isLand) {
                    // Green variations for land
                    const variation = (noise3D(center[0]*10, center[1]*10, center[2]*10) + 1) * 0.5;
                    color = [0.2 + variation * 0.15, 0.5 + variation * 0.3, 0.15 + variation * 0.1];
                } else {
                    // Blue variations for water
                    const variation = (noise3D(center[0]*5, center[1]*5, center[2]*5) + 1) * 0.5;
                    color = [0.1 + variation * 0.1, 0.3 + variation * 0.2, 0.6 + variation * 0.3];
                }

                const baseIndex = vertices.length / 3;
                
                for (const v of [v0, v1, v2]) {
                    vertices.push(v[0] * radius, v[1] * radius, v[2] * radius);
                    normals.push(v[0], v[1], v[2]);
                    colors.push(color[0], color[1], color[2]);
                }
                
                indices.push(baseIndex, baseIndex + 1, baseIndex + 2);
            }

            return {
                vertices: new Float32Array(vertices),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint32Array(indices)
            };
        }

        // Generate trees on land
        function generateTrees(radius, count) {
            const treePositions = [];
            
            // Noise function (same as planet)
            function noise3D(x, y, z) {
                const n = Math.sin(x * 1.5) * Math.cos(y * 1.3) * Math.sin(z * 1.7) +
                         Math.sin(x * 3.1 + 1.2) * Math.cos(y * 2.7 + 0.8) * Math.sin(z * 2.9 + 1.5) * 0.5 +
                         Math.sin(x * 5.3 + 2.1) * Math.cos(y * 4.9 + 1.7) * Math.sin(z * 5.1 + 2.3) * 0.25;
                return n / 1.75;
            }

            function getTerrainType(x, y, z) {
                const n = noise3D(x * 0.05, y * 0.05, z * 0.05);
                return n > -0.1; // true = land, false = water
            }
            
            // Seed random for consistent tree placement
            let seed = 12345;
            function seededRandom() {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                return seed / 0x7fffffff;
            }
            
            // Generate random points on sphere, keep only those on land
            let attempts = 0;
            while (treePositions.length < count && attempts < count * 10) {
                attempts++;
                
                // Random point on sphere using spherical coordinates
                const theta = seededRandom() * Math.PI * 2;
                const phi = Math.acos(2 * seededRandom() - 1);
                
                const x = Math.sin(phi) * Math.cos(theta);
                const y = Math.cos(phi);
                const z = Math.sin(phi) * Math.sin(theta);
                
                const pos = [x * radius, y * radius, z * radius];
                
                // Check if on land
                if (getTerrainType(pos[0], pos[1], pos[2])) {
                    // Add some variation to tree size
                    const scale = 0.7 + seededRandom() * 0.6;
                    treePositions.push({ pos: [x, y, z], scale });
                }
            }
            
            return treePositions;
        }
        
        // Create tree mesh (combined trunk + foliage for all trees)
        function createTreeMesh(treePositions, radius) {
            const vertices = [];
            const normals = [];
            const colors = [];
            const indices = [];
            
            const TRUNK_HEIGHT = 1.5;
            const TRUNK_RADIUS = 0.2;
            const FOLIAGE_HEIGHT = 2.5;
            const FOLIAGE_RADIUS = 1.2;
            const TRUNK_SEGMENTS = 6;
            const FOLIAGE_SEGMENTS = 8;
            
            const trunkColor = [0.4, 0.25, 0.1];
            const foliageColor = [0.1, 0.5, 0.15];
            
            for (const tree of treePositions) {
                const baseIndex = vertices.length / 3;
                const surfacePos = scale(tree.pos, radius);
                const up = tree.pos; // normalized direction from center
                const treeScale = tree.scale;
                
                // Create orthonormal basis for tree orientation
                let tempVec = Math.abs(up[1]) < 0.9 ? [0, 1, 0] : [1, 0, 0];
                const right = normalize(cross(tempVec, up));
                const forward = normalize(cross(up, right));
                
                // Helper to transform local coords to world coords
                function toWorld(localX, localY, localZ) {
                    return [
                        surfacePos[0] + (right[0] * localX + up[0] * localY + forward[0] * localZ) * treeScale,
                        surfacePos[1] + (right[1] * localX + up[1] * localY + forward[1] * localZ) * treeScale,
                        surfacePos[2] + (right[2] * localX + up[2] * localY + forward[2] * localZ) * treeScale
                    ];
                }
                
                function toWorldNormal(localX, localY, localZ) {
                    return normalize([
                        right[0] * localX + up[0] * localY + forward[0] * localZ,
                        right[1] * localX + up[1] * localY + forward[1] * localZ,
                        right[2] * localX + up[2] * localY + forward[2] * localZ
                    ]);
                }
                
                // Generate trunk (cylinder)
                const trunkBaseIdx = vertices.length / 3;
                for (let i = 0; i <= TRUNK_SEGMENTS; i++) {
                    const angle = (i / TRUNK_SEGMENTS) * Math.PI * 2;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    // Bottom vertex
                    const bottom = toWorld(cos * TRUNK_RADIUS, 0, sin * TRUNK_RADIUS);
                    const bottomNorm = toWorldNormal(cos, 0, sin);
                    vertices.push(...bottom);
                    normals.push(...bottomNorm);
                    colors.push(...trunkColor);
                    
                    // Top vertex
                    const top = toWorld(cos * TRUNK_RADIUS, TRUNK_HEIGHT, sin * TRUNK_RADIUS);
                    vertices.push(...top);
                    normals.push(...bottomNorm);
                    colors.push(...trunkColor);
                }
                
                // Trunk indices
                for (let i = 0; i < TRUNK_SEGMENTS; i++) {
                    const i0 = trunkBaseIdx + i * 2;
                    const i1 = trunkBaseIdx + i * 2 + 1;
                    const i2 = trunkBaseIdx + i * 2 + 2;
                    const i3 = trunkBaseIdx + i * 2 + 3;
                    indices.push(i0, i2, i1);
                    indices.push(i1, i2, i3);
                }
                
                // Generate foliage (cone)
                const foliageBaseIdx = vertices.length / 3;
                
                // Cone tip
                const tip = toWorld(0, TRUNK_HEIGHT + FOLIAGE_HEIGHT, 0);
                vertices.push(...tip);
                normals.push(...up);
                colors.push(...foliageColor);
                const tipIdx = foliageBaseIdx;
                
                // Cone base vertices
                for (let i = 0; i <= FOLIAGE_SEGMENTS; i++) {
                    const angle = (i / FOLIAGE_SEGMENTS) * Math.PI * 2;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    const baseVert = toWorld(cos * FOLIAGE_RADIUS, TRUNK_HEIGHT, sin * FOLIAGE_RADIUS);
                    // Cone normal points outward and up
                    const coneNorm = toWorldNormal(cos * 0.7, 0.7, sin * 0.7);
                    vertices.push(...baseVert);
                    normals.push(...coneNorm);
                    colors.push(...foliageColor);
                }
                
                // Foliage cone indices
                for (let i = 0; i < FOLIAGE_SEGMENTS; i++) {
                    const i0 = tipIdx;
                    const i1 = foliageBaseIdx + 1 + i;
                    const i2 = foliageBaseIdx + 1 + i + 1;
                    indices.push(i0, i2, i1);
                }
                
                // Cone bottom cap
                const capCenterIdx = vertices.length / 3;
                const capCenter = toWorld(0, TRUNK_HEIGHT, 0);
                const downNorm = toWorldNormal(0, -1, 0);
                vertices.push(...capCenter);
                normals.push(...downNorm);
                colors.push(...foliageColor);
                
                for (let i = 0; i < FOLIAGE_SEGMENTS; i++) {
                    const i1 = foliageBaseIdx + 1 + i;
                    const i2 = foliageBaseIdx + 1 + i + 1;
                    indices.push(capCenterIdx, i1, i2);
                }
            }
            
            return {
                vertices: new Float32Array(vertices),
                normals: new Float32Array(normals),
                colors: new Float32Array(colors),
                indices: new Uint32Array(indices)
            };
        }

        // Create planet
        const planet = generatePlanet(PLANET_RADIUS, 5);
        
        // Create trees
        const treePositions = generateTrees(PLANET_RADIUS, 500);
        const treeMesh = createTreeMesh(treePositions, PLANET_RADIUS);
        
        // Create VAO
        const vao = gl.createVertexArray();
        gl.bindVertexArray(vao);

        // Position buffer
        const posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, planet.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

        // Normal buffer
        const normBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, planet.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

        // Color buffer
        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, planet.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

        // Index buffer
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, planet.indices, gl.STATIC_DRAW);

        // Create Tree VAO
        const treeVao = gl.createVertexArray();
        gl.bindVertexArray(treeVao);

        // Tree position buffer
        const treePosBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, treePosBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, treeMesh.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

        // Tree normal buffer
        const treeNormBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, treeNormBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, treeMesh.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

        // Tree color buffer
        const treeColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, treeColorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, treeMesh.colors, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

        // Tree index buffer
        const treeIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, treeIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, treeMesh.indices, gl.STATIC_DRAW);

        // Generate player sphere mesh (unit sphere, will be scaled and positioned per player)
        function generatePlayerSphere(segments) {
            const vertices = [];
            const normals = [];
            const indices = [];
            
            for (let lat = 0; lat <= segments; lat++) {
                const theta = lat * Math.PI / segments;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let lon = 0; lon <= segments; lon++) {
                    const phi = lon * 2 * Math.PI / segments;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;
                    
                    vertices.push(x, y, z);
                    normals.push(x, y, z);
                }
            }
            
            for (let lat = 0; lat < segments; lat++) {
                for (let lon = 0; lon < segments; lon++) {
                    const first = lat * (segments + 1) + lon;
                    const second = first + segments + 1;
                    
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }
            
            return {
                vertices: new Float32Array(vertices),
                normals: new Float32Array(normals),
                indices: new Uint32Array(indices)
            };
        }
        
        const playerSphereMesh = generatePlayerSphere(12);
        
        // Create player sphere VAO (geometry only, color set per-player)
        const playerSphereVao = gl.createVertexArray();
        gl.bindVertexArray(playerSphereVao);
        
        const playerSpherePosBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, playerSpherePosBuf);
        gl.bufferData(gl.ARRAY_BUFFER, playerSphereMesh.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);
        
        const playerSphereNormBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, playerSphereNormBuf);
        gl.bufferData(gl.ARRAY_BUFFER, playerSphereMesh.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);
        
        // Color buffer for player sphere - will be updated per draw
        const playerSphereColorBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, playerSphereColorBuf);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);
        
        const playerSphereIdxBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, playerSphereIdxBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, playerSphereMesh.indices, gl.STATIC_DRAW);

        // Generate look direction pointer (cylinder pointing in +Z direction)
        function generatePointerCylinder(radius, length, segments) {
            const vertices = [];
            const normals = [];
            const indices = [];
            
            // Cylinder along Z axis, from 0 to length
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                // Back cap vertex (at z=0)
                vertices.push(cos * radius, sin * radius, 0);
                normals.push(cos, sin, 0);
                
                // Front vertex (at z=length)
                vertices.push(cos * radius, sin * radius, length);
                normals.push(cos, sin, 0);
            }
            
            // Side faces
            for (let i = 0; i < segments; i++) {
                const i0 = i * 2;
                const i1 = i * 2 + 1;
                const i2 = i * 2 + 2;
                const i3 = i * 2 + 3;
                indices.push(i0, i2, i1);
                indices.push(i1, i2, i3);
            }
            
            // Front cap (cone tip for more character)
            const tipIdx = vertices.length / 3;
            vertices.push(0, 0, length + radius * 2); // Cone tip
            normals.push(0, 0, 1);
            
            const frontCapStart = vertices.length / 3;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                vertices.push(cos * radius, sin * radius, length);
                // Cone normal pointing outward and forward
                const nx = cos * 0.7;
                const ny = sin * 0.7;
                const nz = 0.7;
                normals.push(nx, ny, nz);
            }
            
            for (let i = 0; i < segments; i++) {
                indices.push(tipIdx, frontCapStart + i + 1, frontCapStart + i);
            }
            
            return {
                vertices: new Float32Array(vertices),
                normals: new Float32Array(normals),
                indices: new Uint32Array(indices)
            };
        }
        
        const pointerMesh = generatePointerCylinder(0.15, 1.2, 8);
        
        // Create pointer VAO
        const pointerVao = gl.createVertexArray();
        gl.bindVertexArray(pointerVao);
        
        const pointerPosBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pointerPosBuf);
        gl.bufferData(gl.ARRAY_BUFFER, pointerMesh.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);
        
        const pointerNormBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pointerNormBuf);
        gl.bufferData(gl.ARRAY_BUFFER, pointerMesh.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);
        
        const pointerColorBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, pointerColorBuf);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);
        
        const pointerIdxBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, pointerIdxBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, pointerMesh.indices, gl.STATIC_DRAW);

        // Multiplayer state
        const otherPlayers = new Map();
        let myPlayerId = null;
        let myPlayerColor = null;
        let ws = null;
        const PLAYER_SPHERE_RADIUS = 1.0;
        
        // Connect to WebSocket server
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}`);
            
            ws.onopen = () => {
                console.log('Connected to server');
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                switch (data.type) {
                    case 'init':
                        myPlayerId = data.id;
                        myPlayerColor = data.color;
                        console.log('My player ID:', myPlayerId);
                        break;
                        
                    case 'playerJoin':
                        console.log('Player joined:', data.id);
                        otherPlayers.set(data.id, {
                            id: data.id,
                            color: data.color,
                            position: data.position,
                            forward: data.forward,
                            pitch: data.pitch || 0
                        });
                        break;
                        
                    case 'playerMove':
                        const otherPlayer = otherPlayers.get(data.id);
                        if (otherPlayer) {
                            otherPlayer.position = data.position;
                            otherPlayer.forward = data.forward;
                            otherPlayer.pitch = data.pitch || 0;
                        }
                        break;
                        
                    case 'playerLeave':
                        console.log('Player left:', data.id);
                        otherPlayers.delete(data.id);
                        break;
                }
            };
            
            ws.onclose = () => {
                console.log('Disconnected from server, reconnecting...');
                setTimeout(connectWebSocket, 2000);
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }
        
        // Send position update to server
        let lastPositionSent = 0;
        function sendPositionUpdate() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const now = performance.now();
                if (now - lastPositionSent > 50) { // Send at most 20 times per second
                    ws.send(JSON.stringify({
                        type: 'position',
                        position: player.position,
                        forward: player.forward,
                        pitch: player.pitch
                    }));
                    lastPositionSent = now;
                }
            }
        }
        
        // Connect on load
        connectWebSocket();
        
        // Create color array for player sphere
        function createColorArray(color, vertexCount) {
            const colors = new Float32Array(vertexCount * 3);
            for (let i = 0; i < vertexCount; i++) {
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            return colors;
        }
        
        // Matrix for positioning player spheres
        function mat4Translate(x, y, z) {
            return new Float32Array([
                1, 0, 0, 0,
                0, 1, 0, 0,
                0, 0, 1, 0,
                x, y, z, 1
            ]);
        }
        
        function mat4Scale(s) {
            return new Float32Array([
                s, 0, 0, 0,
                0, s, 0, 0,
                0, 0, s, 0,
                0, 0, 0, 1
            ]);
        }
        
        function mat4Multiply(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[j * 4 + i] = 
                        a[i] * b[j * 4] +
                        a[i + 4] * b[j * 4 + 1] +
                        a[i + 8] * b[j * 4 + 2] +
                        a[i + 12] * b[j * 4 + 3];
                }
            }
            return result;
        }
        
        // Create rotation matrix to orient pointer from +Z to look direction
        function mat4FromLookDirection(forward, up) {
            // forward is where the pointer should point
            // up is the player's up direction (away from planet center)
            const f = normalize(forward);
            const r = normalize(cross(f, up));
            const u = normalize(cross(r, f));
            
            // Rotation matrix: columns are right, up, forward
            // But our pointer is along +Z, so we map:
            // +X -> right, +Y -> up, +Z -> forward
            return new Float32Array([
                r[0], r[1], r[2], 0,
                u[0], u[1], u[2], 0,
                f[0], f[1], f[2], 0,
                0, 0, 0, 1
            ]);
        }
        
        // Apply pitch to a horizontal forward direction
        function applyPitchToForward(forward, up, pitch) {
            // forward is horizontal (tangent to sphere), up is radial
            // pitch rotates forward towards up (positive pitch = looking up)
            const cosPitch = Math.cos(-pitch); // negative because our pitch convention
            const sinPitch = Math.sin(-pitch);
            
            // Rotate forward around the right vector (cross of forward and up)
            // Result: forward * cos(pitch) + up * sin(pitch)
            return normalize([
                forward[0] * cosPitch + up[0] * sinPitch,
                forward[1] * cosPitch + up[1] * sinPitch,
                forward[2] * cosPitch + up[2] * sinPitch
            ]);
        }
        
        // Project 3D world position to 2D screen coordinates
        function projectToScreen(worldPos, viewMatrix, projMatrix) {
            // Transform to clip space
            let pos = [worldPos[0], worldPos[1], worldPos[2], 1];
            
            // Apply view matrix
            let viewPos = [
                viewMatrix[0] * pos[0] + viewMatrix[4] * pos[1] + viewMatrix[8] * pos[2] + viewMatrix[12],
                viewMatrix[1] * pos[0] + viewMatrix[5] * pos[1] + viewMatrix[9] * pos[2] + viewMatrix[13],
                viewMatrix[2] * pos[0] + viewMatrix[6] * pos[1] + viewMatrix[10] * pos[2] + viewMatrix[14],
                viewMatrix[3] * pos[0] + viewMatrix[7] * pos[1] + viewMatrix[11] * pos[2] + viewMatrix[15]
            ];
            
            // Apply projection matrix
            let clipPos = [
                projMatrix[0] * viewPos[0] + projMatrix[4] * viewPos[1] + projMatrix[8] * viewPos[2] + projMatrix[12] * viewPos[3],
                projMatrix[1] * viewPos[0] + projMatrix[5] * viewPos[1] + projMatrix[9] * viewPos[2] + projMatrix[13] * viewPos[3],
                projMatrix[2] * viewPos[0] + projMatrix[6] * viewPos[1] + projMatrix[10] * viewPos[2] + projMatrix[14] * viewPos[3],
                projMatrix[3] * viewPos[0] + projMatrix[7] * viewPos[1] + projMatrix[11] * viewPos[2] + projMatrix[15] * viewPos[3]
            ];
            
            // Behind camera check
            if (clipPos[3] <= 0) return null;
            
            // Perspective divide to NDC
            const ndcX = clipPos[0] / clipPos[3];
            const ndcY = clipPos[1] / clipPos[3];
            const ndcZ = clipPos[2] / clipPos[3];
            
            // Check if in view frustum
            if (ndcX < -1 || ndcX > 1 || ndcY < -1 || ndcY > 1 || ndcZ < -1 || ndcZ > 1) {
                return null;
            }
            
            // Convert to screen coordinates
            const screenX = (ndcX + 1) * 0.5 * canvas.width;
            const screenY = (1 - ndcY) * 0.5 * canvas.height; // Flip Y
            
            return { x: screenX, y: screenY, depth: ndcZ };
        }
        
        // Draw nametag for a player
        function drawNametag(playerId, screenPos, color) {
            const shortId = playerId.substring(0, 8);
            
            ctx.font = 'bold 14px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            // Draw background
            const textWidth = ctx.measureText(shortId).width;
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(screenPos.x - textWidth / 2 - 4, screenPos.y - 20, textWidth + 8, 18);
            
            // Draw text with player color
            ctx.fillStyle = `rgb(${Math.floor(color.r * 255)}, ${Math.floor(color.g * 255)}, ${Math.floor(color.b * 255)})`;
            ctx.fillText(shortId, screenPos.x, screenPos.y - 5);
        }

        // Player state
        const player = {
            position: [0, PLANET_RADIUS + PLAYER_HEIGHT, 0],
            velocity: [0, 0, 0],
            // Store the player's forward direction on the sphere surface (tangent)
            // This gets updated as they move to maintain continuity
            forward: [0, 0, -1], // Initial forward direction
            pitch: 0,
            grounded: false
        };

        // Quaternion utilities for smooth rotation
        function quatFromAxisAngle(axis, angle) {
            const s = Math.sin(angle / 2);
            return [axis[0] * s, axis[1] * s, axis[2] * s, Math.cos(angle / 2)];
        }

        function quatMultiply(a, b) {
            return [
                a[3]*b[0] + a[0]*b[3] + a[1]*b[2] - a[2]*b[1],
                a[3]*b[1] - a[0]*b[2] + a[1]*b[3] + a[2]*b[0],
                a[3]*b[2] + a[0]*b[1] - a[1]*b[0] + a[2]*b[3],
                a[3]*b[3] - a[0]*b[0] - a[1]*b[1] - a[2]*b[2]
            ];
        }

        function quatRotateVector(q, v) {
            const qv = [q[0], q[1], q[2]];
            const uv = cross(qv, v);
            const uuv = cross(qv, uv);
            return [
                v[0] + 2 * (q[3] * uv[0] + uuv[0]),
                v[1] + 2 * (q[3] * uv[1] + uuv[1]),
                v[2] + 2 * (q[3] * uv[2] + uuv[2])
            ];
        }

        // Input state
        const keys = {};
        let mouseLocked = false;

        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        document.addEventListener('mousemove', e => {
            if (mouseLocked) {
                const yawDelta = -e.movementX * 0.002;
                const pitchDelta = e.movementY * 0.002;
                
                // Rotate forward vector around up axis for yaw
                const up = normalize(player.position);
                const cosYaw = Math.cos(yawDelta);
                const sinYaw = Math.sin(yawDelta);
                
                // Rodrigues rotation formula around up axis
                let forward = player.forward;
                const forwardDotUp = dot(forward, up);
                forward = subtract(forward, scale(up, forwardDotUp)); // ensure tangent
                if (length(forward) > 0.001) {
                    forward = normalize(forward);
                    const rotated = add(
                        scale(forward, cosYaw),
                        scale(cross(up, forward), sinYaw)
                    );
                    player.forward = normalize(rotated);
                }
                
                // Update pitch (this is just a viewing angle, not affecting forward)
                player.pitch += pitchDelta;
                player.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, player.pitch));
            }
        });

        const instructions = document.getElementById('instructions');
        canvas.addEventListener('click', () => {
            canvas.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === canvas;
            instructions.classList.toggle('hidden', mouseLocked);
        });

        // Physics update
        function updatePhysics(dt) {
            // Get player's "up" direction (away from planet center)
            const up = normalize(player.position);
            
            // Re-orthogonalize forward to be tangent to sphere
            // This maintains a smooth, continuous reference frame
            let forward = player.forward;
            // Remove any component of forward that points along up
            const forwardDotUp = dot(forward, up);
            forward = subtract(forward, scale(up, forwardDotUp));
            
            // If forward became degenerate, pick a new one
            if (length(forward) < 0.001) {
                // Find any vector not parallel to up
                if (Math.abs(up[1]) < 0.9) {
                    forward = [0, 1, 0];
                } else {
                    forward = [1, 0, 0];
                }
                forward = subtract(forward, scale(up, dot(forward, up)));
            }
            forward = normalize(forward);
            player.forward = forward;
            
            // Calculate right vector (forward is now the look direction directly)
            const right = normalize(cross(forward, up));
            
            // Movement input - use forward and right directly (no yaw, it's baked into forward)
            let moveDir = [0, 0, 0];
            if (keys['KeyW']) moveDir = add(moveDir, forward);
            if (keys['KeyS']) moveDir = subtract(moveDir, forward);
            if (keys['KeyD']) moveDir = add(moveDir, right);
            if (keys['KeyA']) moveDir = subtract(moveDir, right);
            
            if (length(moveDir) > 0) {
                moveDir = normalize(moveDir);
                const moveVel = scale(moveDir, MOVE_SPEED);
                // Project current velocity onto up, keep that, replace horizontal
                const verticalVel = scale(up, dot(player.velocity, up));
                player.velocity = add(verticalVel, moveVel);
            } else {
                // Dampen horizontal velocity when not moving
                const verticalVel = scale(up, dot(player.velocity, up));
                const horizontalVel = subtract(player.velocity, verticalVel);
                player.velocity = add(verticalVel, scale(horizontalVel, 0.9));
            }
            
            // Jumping
            if (keys['Space'] && player.grounded) {
                player.velocity = add(player.velocity, scale(up, JUMP_VELOCITY));
                player.grounded = false;
            }
            
            // Gravity (towards planet center)
            const gravityDir = scale(up, -1);
            player.velocity = add(player.velocity, scale(gravityDir, GRAVITY * dt));
            
            // Store old up for rotating forward vector
            const oldUp = up;
            
            // Update position
            player.position = add(player.position, scale(player.velocity, dt));
            
            // Ground collision
            const newDist = length(player.position);
            const newUp = normalize(player.position);
            
            if (newDist < PLANET_RADIUS + PLAYER_HEIGHT) {
                player.position = scale(newUp, PLANET_RADIUS + PLAYER_HEIGHT);
                // Remove velocity towards planet
                const velTowardsPlanet = dot(player.velocity, scale(newUp, -1));
                if (velTowardsPlanet > 0) {
                    player.velocity = add(player.velocity, scale(newUp, velTowardsPlanet));
                }
                player.grounded = true;
            } else {
                player.grounded = false;
            }
            
            // Rotate forward vector to stay tangent as player moves on sphere
            // Calculate rotation from oldUp to newUp
            const rotationAxis = cross(oldUp, newUp);
            const rotationAxisLen = length(rotationAxis);
            if (rotationAxisLen > 0.0001) {
                const angle = Math.asin(Math.min(1, rotationAxisLen));
                const axis = scale(rotationAxis, 1 / rotationAxisLen);
                const q = quatFromAxisAngle(axis, angle);
                player.forward = quatRotateVector(q, player.forward);
                // Re-normalize to prevent drift
                player.forward = normalize(player.forward);
            }
        }

        // Get camera matrices
        function getCameraMatrix() {
            const up = normalize(player.position);
            
            // Use the player's stored forward direction (already tangent to sphere)
            // Forward already includes yaw rotation from mouse input
            let forward = player.forward;
            // Ensure it's orthogonal to up
            forward = subtract(forward, scale(up, dot(forward, up)));
            forward = normalize(forward);
            
            // Calculate right
            const right = normalize(cross(forward, up));
            
            // Apply pitch only (yaw is already baked into forward)
            const cosPitch = Math.cos(-player.pitch);
            const sinPitch = Math.sin(-player.pitch);
            let lookForward = normalize([
                forward[0] * cosPitch + up[0] * sinPitch,
                forward[1] * cosPitch + up[1] * sinPitch,
                forward[2] * cosPitch + up[2] * sinPitch
            ]);
            
            const camUp = normalize(cross(right, lookForward));
            const target = add(player.position, lookForward);
            
            return mat4LookAt(player.position, target, camUp);
        }

        // UI elements
        const posEl = document.getElementById('pos');
        const latEl = document.getElementById('lat');
        const lonEl = document.getElementById('lon');
        const groundedEl = document.getElementById('grounded');

        // Main render loop
        let lastTime = performance.now();
        
        function render(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            // Update physics
            updatePhysics(dt);
            
            // Send position to server
            sendPositionUpdate();

            // Update UI
            const p = player.position;
            posEl.textContent = `${p[0].toFixed(1)}, ${p[1].toFixed(1)}, ${p[2].toFixed(1)}`;
            
            const lat = Math.asin(normalize(p)[1]) * 180 / Math.PI;
            const lon = Math.atan2(normalize(p)[0], normalize(p)[2]) * 180 / Math.PI;
            latEl.textContent = lat.toFixed(1);
            lonEl.textContent = lon.toFixed(1);
            groundedEl.textContent = player.grounded ? 'Yes' : 'No';

            // Clear
            gl.clearColor(0.5, 0.7, 0.9, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            
            // Clear label canvas
            ctx.clearRect(0, 0, labelCanvas.width, labelCanvas.height);

            // Use program
            gl.useProgram(program);

            // Set uniforms
            const projection = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 1000);
            const view = getCameraMatrix();
            const model = mat4Identity();

            gl.uniformMatrix4fv(uniforms.projection, false, projection);
            gl.uniformMatrix4fv(uniforms.view, false, view);
            gl.uniformMatrix4fv(uniforms.model, false, model);
            gl.uniform3f(uniforms.lightDir, 0.5, 1, 0.3);
            gl.uniform3fv(uniforms.cameraPos, player.position);

            // Draw planet
            gl.bindVertexArray(vao);
            gl.drawElements(gl.TRIANGLES, planet.indices.length, gl.UNSIGNED_INT, 0);

            // Draw trees
            gl.bindVertexArray(treeVao);
            gl.drawElements(gl.TRIANGLES, treeMesh.indices.length, gl.UNSIGNED_INT, 0);

            // Draw other players
            gl.bindVertexArray(playerSphereVao);
            const vertexCount = playerSphereMesh.vertices.length / 3;
            const pointerVertexCount = pointerMesh.vertices.length / 3;
            
            otherPlayers.forEach((otherPlayer) => {
                // Create color array for this player
                const colorArray = createColorArray(otherPlayer.color, vertexCount);
                gl.bindBuffer(gl.ARRAY_BUFFER, playerSphereColorBuf);
                gl.bufferData(gl.ARRAY_BUFFER, colorArray, gl.DYNAMIC_DRAW);
                
                // Create model matrix for this player (translate to position, scale)
                const pos = otherPlayer.position;
                const translateMat = mat4Translate(pos[0], pos[1], pos[2]);
                const scaleMat = mat4Scale(PLAYER_SPHERE_RADIUS);
                const playerModel = mat4Multiply(translateMat, scaleMat);
                
                gl.uniformMatrix4fv(uniforms.model, false, playerModel);
                gl.bindVertexArray(playerSphereVao);
                gl.drawElements(gl.TRIANGLES, playerSphereMesh.indices.length, gl.UNSIGNED_INT, 0);
                
                // Draw look direction pointer
                const playerUp = normalize(pos);
                let lookDir = otherPlayer.forward || [0, 0, -1];
                // Ensure lookDir is normalized and tangent to sphere
                lookDir = subtract(lookDir, scale(playerUp, dot(lookDir, playerUp)));
                if (length(lookDir) < 0.001) {
                    lookDir = [0, 0, -1]; // Fallback
                }
                lookDir = normalize(lookDir);
                
                // Apply pitch to get the actual 3D look direction
                const pitch = otherPlayer.pitch || 0;
                const lookDir3D = applyPitchToForward(lookDir, playerUp, pitch);
                
                // Create rotation matrix to orient pointer
                const rotMat = mat4FromLookDirection(lookDir3D, playerUp);
                const pointerTranslate = mat4Translate(pos[0], pos[1], pos[2]);
                const pointerModel = mat4Multiply(pointerTranslate, rotMat);
                
                // Slightly darker color for pointer
                const pointerColor = {
                    r: otherPlayer.color.r * 0.7,
                    g: otherPlayer.color.g * 0.7,
                    b: otherPlayer.color.b * 0.7
                };
                const pointerColorArray = createColorArray(pointerColor, pointerVertexCount);
                
                gl.bindVertexArray(pointerVao);
                gl.bindBuffer(gl.ARRAY_BUFFER, pointerColorBuf);
                gl.bufferData(gl.ARRAY_BUFFER, pointerColorArray, gl.DYNAMIC_DRAW);
                gl.uniformMatrix4fv(uniforms.model, false, pointerModel);
                gl.drawElements(gl.TRIANGLES, pointerMesh.indices.length, gl.UNSIGNED_INT, 0);
                
                // Draw nametag above player
                const nametagPos = [pos[0], pos[1], pos[2]];
                // Offset nametag above the sphere (in the direction away from planet center)
                const upDir = normalize(pos);
                nametagPos[0] += upDir[0] * (PLAYER_SPHERE_RADIUS + 1.5);
                nametagPos[1] += upDir[1] * (PLAYER_SPHERE_RADIUS + 1.5);
                nametagPos[2] += upDir[2] * (PLAYER_SPHERE_RADIUS + 1.5);
                
                const screenPos = projectToScreen(nametagPos, view, projection);
                if (screenPos) {
                    drawNametag(otherPlayer.id, screenPos, otherPlayer.color);
                }
            });
            
            // Update player count
            document.getElementById('playerCount').textContent = otherPlayers.size + 1;
            
            // Reset model matrix
            gl.uniformMatrix4fv(uniforms.model, false, model);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    </script>
</body>
</html>
