<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Globe</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { overflow: hidden; background: #000; }
        canvas { display: block; }
        #labelCanvas { position: fixed; top: 0; left: 0; pointer-events: none; }
        #ui {
            position: fixed; top: 10px; left: 10px; color: white;
            font-family: monospace; font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            pointer-events: none;
        }
        #instructions {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: sans-serif; text-align: center;
            background: rgba(0,0,0,0.8); padding: 30px; border-radius: 10px; cursor: pointer;
        }
        #instructions.hidden { display: none; }
        #crosshair {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 24px; height: 24px; pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: rgba(255,255,255,0.8);
        }
        #crosshair::before { width: 2px; height: 24px; left: 11px; }
        #crosshair::after { width: 24px; height: 2px; top: 11px; }
        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-family: monospace; font-size: 18px;
            background: rgba(0,0,0,0.9); padding: 40px; border-radius: 10px;
            text-align: center; z-index: 1000;
        }
        #loading .bar { width: 300px; height: 20px; background: #333; border-radius: 10px; margin-top: 15px; }
        #loading .fill { height: 100%; background: #4a4; border-radius: 10px; width: 0%; transition: width 0.1s; }
        #hotbar {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 4px; z-index: 50; pointer-events: none;
        }
        .hotbar-slot {
            width: 48px; height: 48px; border: 2px solid rgba(255,255,255,0.3);
            background: rgba(0,0,0,0.5); border-radius: 4px;
            display: flex; align-items: center; justify-content: center;
            position: relative;
        }
        .hotbar-slot.selected { border-color: white; background: rgba(255,255,255,0.15); }
        .hotbar-slot .block-preview {
            width: 30px; height: 30px; border-radius: 3px;
        }
        .hotbar-slot .key-hint {
            position: absolute; top: 2px; left: 4px; font-size: 10px;
            color: rgba(255,255,255,0.6); font-family: monospace;
        }

        /* Mobile touch controls */
        .touch-controls {
            display: none; position: fixed; bottom: 0; left: 0; right: 0;
            height: 40vh; pointer-events: none; z-index: 100;
        }
        @media (max-width: 768px), (pointer: coarse) {
            .touch-controls { display: flex; }
            #instructions { display: none !important; }
            #crosshair { display: none; }
            #ui { font-size: 11px; padding: 6px; }
            #hotbar { bottom: 42vh; }
        }
        .trackpad {
            width: 50%; height: 100%; pointer-events: auto; position: relative;
        }
        .trackpad-inner {
            position: absolute; bottom: 20px; width: 120px; height: 120px;
            border-radius: 50%; background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
        }
        .trackpad-left .trackpad-inner { left: 20px; }
        .trackpad-right .trackpad-inner { right: 20px; }
        .trackpad-thumb {
            position: absolute; width: 50px; height: 50px; border-radius: 50%;
            background: rgba(255,255,255,0.4); top: 50%; left: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        .trackpad-label {
            position: absolute; bottom: 150px; color: rgba(255,255,255,0.5);
            font-family: sans-serif; font-size: 12px; text-transform: uppercase;
        }
        .trackpad-left .trackpad-label { left: 40px; }
        .trackpad-right .trackpad-label { right: 40px; }
        .jump-button, .break-button, .place-button {
            position: absolute; width: 60px; height: 60px; border-radius: 50%;
            background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.4);
            pointer-events: auto; display: flex; align-items: center; justify-content: center;
            color: rgba(255,255,255,0.6); font-family: sans-serif; font-size: 11px; font-weight: bold;
        }
        .jump-button { bottom: 160px; right: 30px; }
        .break-button { bottom: 230px; right: 30px; background: rgba(255,80,80,0.2); border-color: rgba(255,80,80,0.4); }
        .place-button { bottom: 160px; right: 100px; background: rgba(80,180,80,0.2); border-color: rgba(80,180,80,0.4); }
        .jump-button:active, .break-button:active, .place-button:active { background: rgba(255,255,255,0.4); }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <canvas id="labelCanvas"></canvas>
    <div id="loading">
        <div>Generating world...</div>
        <div class="bar"><div class="fill" id="loadingFill"></div></div>
        <div id="loadingText" style="margin-top:8px;font-size:13px;color:#aaa;">0%</div>
    </div>
    <div id="ui">
        <div>Position: <span id="pos">0, 0, 0</span></div>
        <div>Latitude: <span id="lat">0</span>&deg; Longitude: <span id="lon">0</span>&deg;</div>
        <div>Grounded: <span id="grounded">No</span></div>
        <div>Players: <span id="playerCount">1</span></div>
        <div>Block: <span id="blockName">Grass</span></div>
    </div>
    <div id="instructions">
        <h2>Voxel Globe</h2>
        <p><br>Click to start</p>
        <p><br>WASD - Move &nbsp; Space - Jump</p>
        <p>Mouse - Look &nbsp; ESC - Release</p>
        <p>Left Click - Break &nbsp; Right Click - Place</p>
        <p>1-7 - Select block type</p>
    </div>
    <div id="crosshair"></div>
    <div id="hotbar"></div>

    <div class="touch-controls" id="touchControls">
        <div class="trackpad trackpad-left" id="moveTrackpad">
            <span class="trackpad-label">Move</span>
            <div class="trackpad-inner"><div class="trackpad-thumb" id="moveThumb"></div></div>
        </div>
        <div class="trackpad trackpad-right" id="lookTrackpad">
            <span class="trackpad-label">Look</span>
            <div class="trackpad-inner"><div class="trackpad-thumb" id="lookThumb"></div></div>
            <div class="jump-button" id="jumpButton">JUMP</div>
            <div class="break-button" id="breakButton">DIG</div>
            <div class="place-button" id="placeButton">PUT</div>
        </div>
    </div>

    <script type="module">
        // ===== WEBGL SETUP =====
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl2');
        if (!gl) alert('WebGL2 not supported!');

        const labelCanvas = document.getElementById('labelCanvas');
        const ctx = labelCanvas.getContext('2d');

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            labelCanvas.width = window.innerWidth;
            labelCanvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        // ===== SHADERS =====
        const vertexShaderSource = `#version 300 es
            in vec3 aPosition;
            in vec3 aNormal;
            in vec3 aColor;
            uniform mat4 uProjection;
            uniform mat4 uView;
            uniform mat4 uModel;
            out vec3 vNormal;
            out vec3 vColor;
            out vec3 vPosition;
            void main() {
                vec4 worldPos = uModel * vec4(aPosition, 1.0);
                vPosition = worldPos.xyz;
                vNormal = mat3(uModel) * aNormal;
                vColor = aColor;
                gl_Position = uProjection * uView * worldPos;
            }
        `;

        const fragmentShaderSource = `#version 300 es
            precision highp float;
            in vec3 vNormal;
            in vec3 vColor;
            in vec3 vPosition;
            uniform vec3 uLightDir;
            uniform vec3 uCameraPos;
            out vec4 fragColor;
            void main() {
                vec3 normal = normalize(vNormal);
                vec3 lightDir = normalize(uLightDir);
                float ambient = 0.35;
                float diff = max(dot(normal, lightDir), 0.0);
                vec3 color = vColor * (ambient + diff * 0.65);
                float dist = length(vPosition - uCameraPos);
                float fog = 1.0 - clamp(dist / 500.0, 0.0, 0.8);
                color = mix(vec3(0.5, 0.7, 0.9), color, fog);
                fragColor = vec4(color, 1.0);
            }
        `;

        // Highlight shader for block wireframe
        const highlightVertSource = `#version 300 es
            in vec3 aPosition;
            uniform mat4 uProjection;
            uniform mat4 uView;
            void main() {
                gl_Position = uProjection * uView * vec4(aPosition, 1.0);
            }
        `;
        const highlightFragSource = `#version 300 es
            precision highp float;
            out vec4 fragColor;
            void main() {
                fragColor = vec4(1.0, 1.0, 1.0, 0.9);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vs, fs) {
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error(gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        const uniforms = {
            projection: gl.getUniformLocation(program, 'uProjection'),
            view: gl.getUniformLocation(program, 'uView'),
            model: gl.getUniformLocation(program, 'uModel'),
            lightDir: gl.getUniformLocation(program, 'uLightDir'),
            cameraPos: gl.getUniformLocation(program, 'uCameraPos')
        };
        const attribs = {
            position: gl.getAttribLocation(program, 'aPosition'),
            normal: gl.getAttribLocation(program, 'aNormal'),
            color: gl.getAttribLocation(program, 'aColor')
        };

        // Highlight program
        const hlVS = createShader(gl, gl.VERTEX_SHADER, highlightVertSource);
        const hlFS = createShader(gl, gl.FRAGMENT_SHADER, highlightFragSource);
        const hlProgram = createProgram(gl, hlVS, hlFS);
        const hlUniforms = {
            projection: gl.getUniformLocation(hlProgram, 'uProjection'),
            view: gl.getUniformLocation(hlProgram, 'uView')
        };
        const hlAttribPos = gl.getAttribLocation(hlProgram, 'aPosition');

        // ===== MATH UTILITIES =====
        function mat4Perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,2*far*near*nf,0]);
        }
        function mat4LookAt(eye, center, up) {
            const z = normalize(subtract(eye, center));
            const x = normalize(cross(up, z));
            const y = cross(z, x);
            return new Float32Array([x[0],y[0],z[0],0, x[1],y[1],z[1],0, x[2],y[2],z[2],0, -dot(x,eye),-dot(y,eye),-dot(z,eye),1]);
        }
        function mat4Identity() { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
        function mat4Translate(x,y,z) { return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]); }
        function mat4Scale(s) { return new Float32Array([s,0,0,0, 0,s,0,0, 0,0,s,0, 0,0,0,1]); }
        function mat4Multiply(a, b) {
            const r = new Float32Array(16);
            for (let i = 0; i < 4; i++)
                for (let j = 0; j < 4; j++)
                    r[j*4+i] = a[i]*b[j*4] + a[i+4]*b[j*4+1] + a[i+8]*b[j*4+2] + a[i+12]*b[j*4+3];
            return r;
        }

        function vec3(x,y,z) { return [x,y,z]; }
        function add(a,b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
        function subtract(a,b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function scale(v,s) { return [v[0]*s, v[1]*s, v[2]*s]; }
        function dot(a,b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }
        function cross(a,b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function length(v) { return Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]); }
        function normalize(v) { const l = length(v); return l > 0 ? [v[0]/l, v[1]/l, v[2]/l] : [0,0,0]; }

        // ===== CONFIGURATION =====
        // Cube-sphere: R=214, N=168, h=2.0 → cell side = Rπ/(2N) ≈ 2.001 → near-perfect cubes
        const PLANET_RADIUS = 214;
        const PLAYER_HEIGHT = 2;
        const GRAVITY = 30;
        const MOVE_SPEED = 15;
        const JUMP_VELOCITY = 12;
        const GRID_N = 168; // cells per cube face edge
        const NUM_LAYERS = 15;
        const SURFACE_LAYER = 7;
        const BLOCK_HEIGHT = 2.0;
        const INNER_RADIUS = PLANET_RADIUS - SURFACE_LAYER * BLOCK_HEIGHT; // 200
        const CHUNK_N = 24; // cells per chunk edge
        const CHUNKS_PER_EDGE = GRID_N / CHUNK_N; // 7
        const CHUNKS_PER_FACE = CHUNKS_PER_EDGE * CHUNKS_PER_EDGE; // 49
        const TOTAL_CHUNKS = 6 * CHUNKS_PER_FACE; // 294
        const TOTAL_CELLS = 6 * GRID_N * GRID_N; // 169,344
        const VIEW_ANGLE_COS = Math.cos(Math.PI / 3); // 60 degrees

        // Block types
        const BLOCK_AIR = 0;
        const BLOCK_GRASS = 1;
        const BLOCK_DIRT = 2;
        const BLOCK_STONE = 3;
        const BLOCK_WATER = 4;
        const BLOCK_SAND = 5;
        const BLOCK_WOOD = 6;
        const BLOCK_LEAVES = 7;

        const BLOCK_NAMES = ['Air', 'Grass', 'Dirt', 'Stone', 'Water', 'Sand', 'Wood', 'Leaves'];
        const BLOCK_COLORS = [
            [0,0,0],             // air (unused)
            [0.3, 0.7, 0.2],    // grass top
            [0.55, 0.35, 0.2],  // dirt
            [0.5, 0.5, 0.5],    // stone
            [0.2, 0.4, 0.8],    // water
            [0.9, 0.85, 0.6],   // sand
            [0.45, 0.28, 0.12], // wood
            [0.15, 0.55, 0.15], // leaves
        ];
        // Grass side color (dirt-like)
        const GRASS_SIDE_COLOR = [0.5, 0.38, 0.22];

        // ===== ICOSPHERE TOPOLOGY =====
        function buildIcosphereTopology(subdivisions) {
            const t = (1 + Math.sqrt(5)) / 2;
            let vertices = [
                [-1,t,0],[1,t,0],[-1,-t,0],[1,-t,0],
                [0,-1,t],[0,1,t],[0,-1,-t],[0,1,-t],
                [t,0,-1],[t,0,1],[-t,0,-1],[-t,0,1]
            ].map(v => normalize(v));

            let faces = [
                [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
                [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
                [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
                [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]
            ];

            // Track parent-child for hierarchy and chunk assignment
            // faceLevel[level] = array of face index arrays
            const faceLevels = [faces.map((_, i) => i)]; // level 0: faces 0-19

            const midpointCache = {};
            function getMidpoint(i1, i2) {
                const key = i1 < i2 ? `${i1}_${i2}` : `${i2}_${i1}`;
                if (midpointCache[key] !== undefined) return midpointCache[key];
                const v1 = vertices[i1], v2 = vertices[i2];
                const mid = normalize([(v1[0]+v2[0])/2, (v1[1]+v2[1])/2, (v1[2]+v2[2])/2]);
                vertices.push(mid);
                midpointCache[key] = vertices.length - 1;
                return midpointCache[key];
            }

            // faceChildren[faceIdx] = [child0, child1, child2, child3] at next level
            const faceChildren = [];

            for (let level = 0; level < subdivisions; level++) {
                const newFaces = [];
                const levelIndices = [];
                for (let fi = 0; fi < faces.length; fi++) {
                    const face = faces[fi];
                    const a = getMidpoint(face[0], face[1]);
                    const b = getMidpoint(face[1], face[2]);
                    const c = getMidpoint(face[2], face[0]);

                    const startIdx = newFaces.length;
                    newFaces.push([face[0], a, c]);
                    newFaces.push([face[1], b, a]);
                    newFaces.push([face[2], c, b]);
                    newFaces.push([a, b, c]);

                    faceChildren[fi + (level > 0 ? faces.length - newFaces.length + startIdx : 0)] = undefined; // placeholder
                    // We track by absolute face index across all levels
                }

                // Build children mapping: each old face -> 4 new faces
                // Old faces are indexed 0..faces.length-1 at current level
                // New faces will be indexed 0..newFaces.length-1 at next level
                const childMap = new Array(faces.length);
                for (let fi = 0; fi < faces.length; fi++) {
                    childMap[fi] = [fi * 4, fi * 4 + 1, fi * 4 + 2, fi * 4 + 3];
                }

                faceLevels.push(newFaces.map((_, i) => i));
                faces = newFaces;

                // Store children mapping for this level
                if (!buildIcosphereTopology._childMaps) buildIcosphereTopology._childMaps = [];
                buildIcosphereTopology._childMaps[level] = childMap;
            }

            const faceCount = faces.length;
            const vertexCount = vertices.length;

            // Build flat arrays
            const vertArray = new Float64Array(vertexCount * 3);
            for (let i = 0; i < vertexCount; i++) {
                vertArray[i*3] = vertices[i][0];
                vertArray[i*3+1] = vertices[i][1];
                vertArray[i*3+2] = vertices[i][2];
            }

            const faceArray = new Uint32Array(faceCount * 3);
            for (let i = 0; i < faceCount; i++) {
                faceArray[i*3] = faces[i][0];
                faceArray[i*3+1] = faces[i][1];
                faceArray[i*3+2] = faces[i][2];
            }

            // Compute face centers
            const faceCenters = new Float64Array(faceCount * 3);
            for (let i = 0; i < faceCount; i++) {
                const v0 = faces[i][0], v1 = faces[i][1], v2 = faces[i][2];
                const cx = (vertices[v0][0] + vertices[v1][0] + vertices[v2][0]) / 3;
                const cy = (vertices[v0][1] + vertices[v1][1] + vertices[v2][1]) / 3;
                const cz = (vertices[v0][2] + vertices[v1][2] + vertices[v2][2]) / 3;
                const cl = Math.sqrt(cx*cx + cy*cy + cz*cz);
                faceCenters[i*3] = cx/cl;
                faceCenters[i*3+1] = cy/cl;
                faceCenters[i*3+2] = cz/cl;
            }

            // Build face adjacency via edge map
            const edgeMap = new Map();
            function edgeKey(a, b) { return a < b ? (a * vertexCount + b) : (b * vertexCount + a); }

            for (let i = 0; i < faceCount; i++) {
                const v0 = faces[i][0], v1 = faces[i][1], v2 = faces[i][2];
                const edges = [[v0,v1],[v1,v2],[v2,v0]];
                for (let e = 0; e < 3; e++) {
                    const key = edgeKey(edges[e][0], edges[e][1]);
                    if (!edgeMap.has(key)) {
                        edgeMap.set(key, []);
                    }
                    edgeMap.get(key).push({ face: i, edge: e });
                }
            }

            const faceNeighbors = new Int32Array(faceCount * 3).fill(-1);
            for (const [, entries] of edgeMap) {
                if (entries.length === 2) {
                    const a = entries[0], b = entries[1];
                    faceNeighbors[a.face * 3 + a.edge] = b.face;
                    faceNeighbors[b.face * 3 + b.edge] = a.face;
                }
            }

            // Chunk assignment: trace ancestry to CHUNK_LEVEL
            // At level 0 we have 20 faces. Each subdivision multiplies by 4.
            // At CHUNK_LEVEL=2 we have 20*4^2=320 chunks.
            // Each final face maps to one chunk.
            // Strategy: for each final face, trace back through child maps to find level-2 ancestor.
            const chunkCount = 20 * Math.pow(4, CHUNK_LEVEL); // 320
            const facesPerChunk = Math.pow(4, subdivisions - CHUNK_LEVEL); // 4^3 = 64
            const faceToChunk = new Uint16Array(faceCount);

            // Build forward mapping: for each level-2 face, find all level-5 descendants
            // Using the child maps
            const childMaps = buildIcosphereTopology._childMaps;

            // Start with chunk-level faces (level CHUNK_LEVEL has chunkCount faces)
            // Trace forward to final level
            function getDescendants(faceIdx, fromLevel, toLevel) {
                if (fromLevel === toLevel) return [faceIdx];
                const children = childMaps[fromLevel];
                if (!children || !children[faceIdx]) return [faceIdx];
                const result = [];
                for (const child of children[faceIdx]) {
                    result.push(...getDescendants(child, fromLevel + 1, toLevel));
                }
                return result;
            }

            const chunkFaces = new Array(chunkCount);
            const chunkCenters = new Float64Array(chunkCount * 3);

            for (let c = 0; c < chunkCount; c++) {
                const descendants = getDescendants(c, CHUNK_LEVEL, subdivisions);
                chunkFaces[c] = new Uint32Array(descendants);
                for (const f of descendants) {
                    faceToChunk[f] = c;
                }
                // Chunk center = average of face centers
                let cx = 0, cy = 0, cz = 0;
                for (const f of descendants) {
                    cx += faceCenters[f*3];
                    cy += faceCenters[f*3+1];
                    cz += faceCenters[f*3+2];
                }
                const cl = Math.sqrt(cx*cx + cy*cy + cz*cz);
                chunkCenters[c*3] = cx/cl;
                chunkCenters[c*3+1] = cy/cl;
                chunkCenters[c*3+2] = cz/cl;
            }

            // Build hierarchical lookup: for each face at each level, store its 4 children
            // We need: level 0 (20 faces) -> level 1 (80) -> ... -> level 5 (20480)
            const hierarchy = [];
            for (let level = 0; level < subdivisions; level++) {
                hierarchy[level] = childMaps[level];
            }

            // Clean up
            delete buildIcosphereTopology._childMaps;

            return {
                vertices, vertArray, vertexCount,
                faces, faceArray, faceCount,
                faceCenters, faceNeighbors,
                faceToChunk, chunkFaces, chunkCenters, chunkCount,
                hierarchy, facesPerChunk
            };
        }

        // ===== FACE LOOKUP (centroid-based hierarchical descent) =====
        function buildFaceLookup(topo) {
            // Build face centroids at each subdivision level using compact Float64Arrays.
            // This avoids storing full face vertex arrays (which would be huge at level 7).
            const t = (1 + Math.sqrt(5)) / 2;
            let verts = [
                [-1,t,0],[1,t,0],[-1,-t,0],[1,-t,0],
                [0,-1,t],[0,1,t],[0,-1,-t],[0,1,-t],
                [t,0,-1],[t,0,1],[-t,0,-1],[-t,0,1]
            ].map(v => normalize(v));
            let faces = [
                [0,11,5],[0,5,1],[0,1,7],[0,7,10],[0,10,11],
                [1,5,9],[5,11,4],[11,10,2],[10,7,6],[7,1,8],
                [3,9,4],[3,4,2],[3,2,6],[3,6,8],[3,8,9],
                [4,9,5],[2,4,11],[6,2,10],[8,6,7],[9,8,1]
            ];

            function computeCentroids(faceList) {
                const c = new Float64Array(faceList.length * 3);
                for (let i = 0; i < faceList.length; i++) {
                    const f = faceList[i];
                    const v0 = verts[f[0]], v1 = verts[f[1]], v2 = verts[f[2]];
                    let cx = (v0[0]+v1[0]+v2[0])/3, cy = (v0[1]+v1[1]+v2[1])/3, cz = (v0[2]+v1[2]+v2[2])/3;
                    const cl = Math.sqrt(cx*cx+cy*cy+cz*cz);
                    c[i*3] = cx/cl; c[i*3+1] = cy/cl; c[i*3+2] = cz/cl;
                }
                return c;
            }

            const levelCentroids = [computeCentroids(faces)];
            const mc = {};
            function gm(a,b) {
                const k = a<b ? a*200000+b : b*200000+a; // numeric key for speed
                if (mc[k] !== undefined) return mc[k];
                const v1=verts[a], v2=verts[b];
                verts.push(normalize([(v1[0]+v2[0])/2,(v1[1]+v2[1])/2,(v1[2]+v2[2])/2]));
                mc[k] = verts.length-1;
                return mc[k];
            }

            for (let level = 0; level < SUBDIVISIONS; level++) {
                const nf = [];
                for (const f of faces) {
                    const a=gm(f[0],f[1]), b=gm(f[1],f[2]), c=gm(f[2],f[0]);
                    nf.push([f[0],a,c], [f[1],b,a], [f[2],c,b], [a,b,c]);
                }
                faces = nf;
                levelCentroids.push(computeCentroids(faces));
            }

            // Free intermediate data
            verts = null; faces = null;

            const numLevels = levelCentroids.length; // SUBDIVISIONS + 1

            return function findClosestFace(dir) {
                const dx = dir[0], dy = dir[1], dz = dir[2];
                // Level 0: test all 20 base faces
                let c0 = levelCentroids[0];
                let best = 0, bestDot = dx*c0[0] + dy*c0[1] + dz*c0[2];
                for (let i = 1; i < 20; i++) {
                    const d = dx*c0[i*3] + dy*c0[i*3+1] + dz*c0[i*3+2];
                    if (d > bestDot) { bestDot = d; best = i; }
                }
                // Descend through levels
                for (let level = 1; level < numLevels; level++) {
                    const cl = levelCentroids[level];
                    const base = best * 4;
                    best = base;
                    bestDot = dx*cl[base*3] + dy*cl[base*3+1] + dz*cl[base*3+2];
                    for (let c = 1; c < 4; c++) {
                        const idx = (base + c) * 3;
                        const d = dx*cl[idx] + dy*cl[idx+1] + dz*cl[idx+2];
                        if (d > bestDot) { bestDot = d; best = base + c; }
                    }
                }
                return best;
            };
        }

        // ===== WORLD DATA & TERRAIN =====
        function noise3D(x, y, z) {
            const n = Math.sin(x*1.5)*Math.cos(y*1.3)*Math.sin(z*1.7) +
                      Math.sin(x*3.1+1.2)*Math.cos(y*2.7+0.8)*Math.sin(z*2.9+1.5)*0.5 +
                      Math.sin(x*5.3+2.1)*Math.cos(y*4.9+1.7)*Math.sin(z*5.1+2.3)*0.25;
            return n / 1.75;
        }

        function generateTerrain(topo, worldBlocks) {
            for (let f = 0; f < topo.faceCount; f++) {
                const cx = topo.faceCenters[f*3];
                const cy = topo.faceCenters[f*3+1];
                const cz = topo.faceCenters[f*3+2];
                const px = cx * PLANET_RADIUS;
                const py = cy * PLANET_RADIUS;
                const pz = cz * PLANET_RADIUS;

                const heightNoise = noise3D(px * 0.05, py * 0.05, pz * 0.05);
                const surfaceLayer = SURFACE_LAYER + Math.round(heightNoise * 3);
                const isLow = surfaceLayer < SURFACE_LAYER - 1;

                for (let layer = 0; layer < NUM_LAYERS; layer++) {
                    if (layer > surfaceLayer) {
                        if (isLow && layer <= SURFACE_LAYER) {
                            worldBlocks[f * NUM_LAYERS + layer] = BLOCK_WATER;
                        } else {
                            worldBlocks[f * NUM_LAYERS + layer] = BLOCK_AIR;
                        }
                    } else if (layer === surfaceLayer) {
                        worldBlocks[f * NUM_LAYERS + layer] = isLow ? BLOCK_SAND : BLOCK_GRASS;
                    } else if (layer > surfaceLayer - 3) {
                        worldBlocks[f * NUM_LAYERS + layer] = BLOCK_DIRT;
                    } else {
                        worldBlocks[f * NUM_LAYERS + layer] = BLOCK_STONE;
                    }
                }
            }

            // Place trees
            let seed = 12345;
            function seededRandom() {
                seed = (seed * 1103515245 + 12345) & 0x7fffffff;
                return seed / 0x7fffffff;
            }
            let treesPlaced = 0;
            for (let f = 0; f < topo.faceCount && treesPlaced < 300; f++) {
                if (seededRandom() > 0.02) continue; // ~2% chance per face
                // Check if surface is grass and has room
                let surfLayer = -1;
                for (let l = NUM_LAYERS - 1; l >= 0; l--) {
                    if (worldBlocks[f * NUM_LAYERS + l] !== BLOCK_AIR && worldBlocks[f * NUM_LAYERS + l] !== BLOCK_WATER) {
                        surfLayer = l;
                        break;
                    }
                }
                if (surfLayer < 0 || worldBlocks[f * NUM_LAYERS + surfLayer] !== BLOCK_GRASS) continue;
                if (surfLayer + 4 >= NUM_LAYERS) continue;

                // Place trunk (2 blocks)
                worldBlocks[f * NUM_LAYERS + surfLayer + 1] = BLOCK_WOOD;
                worldBlocks[f * NUM_LAYERS + surfLayer + 2] = BLOCK_WOOD;
                // Place leaves on top
                worldBlocks[f * NUM_LAYERS + surfLayer + 3] = BLOCK_LEAVES;
                worldBlocks[f * NUM_LAYERS + surfLayer + 4] = BLOCK_LEAVES;
                treesPlaced++;
            }
        }

        function getBlock(worldBlocks, faceIdx, layer) {
            if (layer < 0 || layer >= NUM_LAYERS) return layer < 0 ? BLOCK_STONE : BLOCK_AIR;
            return worldBlocks[faceIdx * NUM_LAYERS + layer];
        }

        function setBlock(worldBlocks, faceIdx, layer, blockType) {
            if (layer < 0 || layer >= NUM_LAYERS) return;
            worldBlocks[faceIdx * NUM_LAYERS + layer] = blockType;
        }

        function layerInnerRadius(layer) { return INNER_RADIUS + layer * BLOCK_HEIGHT; }
        function layerOuterRadius(layer) { return INNER_RADIUS + (layer + 1) * BLOCK_HEIGHT; }

        function isTransparent(blockType) {
            return blockType === BLOCK_AIR || blockType === BLOCK_WATER;
        }

        // ===== CHUNK MESH BUILDER =====
        function buildChunkMesh(chunk, topo, worldBlocks) {
            const positions = [];
            const normals = [];
            const colors = [];
            const indices = [];
            let vertCount = 0;

            function pushVert(pos, norm, col) {
                positions.push(pos[0], pos[1], pos[2]);
                normals.push(norm[0], norm[1], norm[2]);
                colors.push(col[0], col[1], col[2]);
                return vertCount++;
            }

            function emitTri(p0, p1, p2, norm, col) {
                const i0 = pushVert(p0, norm, col);
                const i1 = pushVert(p1, norm, col);
                const i2 = pushVert(p2, norm, col);
                indices.push(i0, i1, i2);
            }

            function emitQuad(p0, p1, p2, p3, norm, col) {
                const i0 = pushVert(p0, norm, col);
                const i1 = pushVert(p1, norm, col);
                const i2 = pushVert(p2, norm, col);
                const i3 = pushVert(p3, norm, col);
                indices.push(i0, i1, i2, i0, i2, i3);
            }

            for (const faceIdx of chunk.faceIndices) {
                const vi0 = topo.faceArray[faceIdx * 3];
                const vi1 = topo.faceArray[faceIdx * 3 + 1];
                const vi2 = topo.faceArray[faceIdx * 3 + 2];
                const d0 = topo.vertices[vi0];
                const d1 = topo.vertices[vi1];
                const d2 = topo.vertices[vi2];

                const n0 = topo.faceNeighbors[faceIdx * 3];
                const n1 = topo.faceNeighbors[faceIdx * 3 + 1];
                const n2 = topo.faceNeighbors[faceIdx * 3 + 2];

                const faceCenter = [
                    topo.faceCenters[faceIdx*3],
                    topo.faceCenters[faceIdx*3+1],
                    topo.faceCenters[faceIdx*3+2]
                ];

                for (let layer = 0; layer < NUM_LAYERS; layer++) {
                    const block = getBlock(worldBlocks, faceIdx, layer);
                    if (block === BLOCK_AIR) continue;
                    if (block === BLOCK_WATER) continue; // skip water rendering for now

                    const rI = layerInnerRadius(layer);
                    const rO = layerOuterRadius(layer);

                    const topColor = (block === BLOCK_GRASS) ? BLOCK_COLORS[BLOCK_GRASS] : BLOCK_COLORS[block];
                    const sideColor = (block === BLOCK_GRASS) ? GRASS_SIDE_COLOR : BLOCK_COLORS[block];

                    // 6 corner positions
                    const p0i = scale(d0, rI), p1i = scale(d1, rI), p2i = scale(d2, rI);
                    const p0o = scale(d0, rO), p1o = scale(d1, rO), p2o = scale(d2, rO);

                    // Top face (outer) - check block above
                    const above = getBlock(worldBlocks, faceIdx, layer + 1);
                    if (isTransparent(above)) {
                        emitTri(p0o, p1o, p2o, faceCenter, topColor);
                    }

                    // Bottom face (inner) - check block below
                    const below = getBlock(worldBlocks, faceIdx, layer - 1);
                    if (isTransparent(below)) {
                        const negCenter = scale(faceCenter, -1);
                        emitTri(p0i, p2i, p1i, negCenter, sideColor);
                    }

                    // Side faces: normal = outward from face center toward edge midpoint
                    // Side face 0: edge v0-v1, neighbor n0
                    if (n0 >= 0 && isTransparent(getBlock(worldBlocks, n0, layer))) {
                        const em0 = normalize([(d0[0]+d1[0])/2,(d0[1]+d1[1])/2,(d0[2]+d1[2])/2]);
                        const sn0 = normalize([em0[0]-faceCenter[0],em0[1]-faceCenter[1],em0[2]-faceCenter[2]]);
                        const tn0 = cross(subtract(p1i, p0i), subtract(p1o, p0i));
                        if (dot(tn0, sn0) > 0) {
                            emitQuad(p0i, p1i, p1o, p0o, sn0, sideColor);
                        } else {
                            emitQuad(p0i, p0o, p1o, p1i, sn0, sideColor);
                        }
                    }

                    // Side face 1: edge v1-v2, neighbor n1
                    if (n1 >= 0 && isTransparent(getBlock(worldBlocks, n1, layer))) {
                        const em1 = normalize([(d1[0]+d2[0])/2,(d1[1]+d2[1])/2,(d1[2]+d2[2])/2]);
                        const sn1 = normalize([em1[0]-faceCenter[0],em1[1]-faceCenter[1],em1[2]-faceCenter[2]]);
                        const tn1 = cross(subtract(p2i, p1i), subtract(p2o, p1i));
                        if (dot(tn1, sn1) > 0) {
                            emitQuad(p1i, p2i, p2o, p1o, sn1, sideColor);
                        } else {
                            emitQuad(p1i, p1o, p2o, p2i, sn1, sideColor);
                        }
                    }

                    // Side face 2: edge v2-v0, neighbor n2
                    if (n2 >= 0 && isTransparent(getBlock(worldBlocks, n2, layer))) {
                        const em2 = normalize([(d2[0]+d0[0])/2,(d2[1]+d0[1])/2,(d2[2]+d0[2])/2]);
                        const sn2 = normalize([em2[0]-faceCenter[0],em2[1]-faceCenter[1],em2[2]-faceCenter[2]]);
                        const tn2 = cross(subtract(p0i, p2i), subtract(p0o, p2i));
                        if (dot(tn2, sn2) > 0) {
                            emitQuad(p2i, p0i, p0o, p2o, sn2, sideColor);
                        } else {
                            emitQuad(p2i, p2o, p0o, p0i, sn2, sideColor);
                        }
                    }
                }
            }

            // Upload to GPU
            if (indices.length === 0) {
                chunk.indexCount = 0;
                chunk.dirty = false;
                return;
            }

            if (!chunk.vao) {
                chunk.vao = gl.createVertexArray();
                chunk.posBuf = gl.createBuffer();
                chunk.normBuf = gl.createBuffer();
                chunk.colorBuf = gl.createBuffer();
                chunk.idxBuf = gl.createBuffer();
            }

            gl.bindVertexArray(chunk.vao);

            gl.bindBuffer(gl.ARRAY_BUFFER, chunk.posBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(attribs.position);
            gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, chunk.normBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(attribs.normal);
            gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, chunk.colorBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(attribs.color);
            gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, chunk.idxBuf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.DYNAMIC_DRAW);

            chunk.indexCount = indices.length;
            chunk.dirty = false;
        }

        // ===== BLOCK HIGHLIGHT =====
        let hlVao = null, hlPosBuf = null, hlIdxBuf = null;
        function initHighlight() {
            hlVao = gl.createVertexArray();
            hlPosBuf = gl.createBuffer();
            hlIdxBuf = gl.createBuffer();
            gl.bindVertexArray(hlVao);
            gl.bindBuffer(gl.ARRAY_BUFFER, hlPosBuf);
            gl.enableVertexAttribArray(hlAttribPos);
            gl.vertexAttribPointer(hlAttribPos, 3, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, hlIdxBuf);
        }

        function drawBlockHighlight(faceIdx, layer, topo, viewMat, projMat) {
            const vi0 = topo.faceArray[faceIdx * 3];
            const vi1 = topo.faceArray[faceIdx * 3 + 1];
            const vi2 = topo.faceArray[faceIdx * 3 + 2];
            const d0 = topo.vertices[vi0];
            const d1 = topo.vertices[vi1];
            const d2 = topo.vertices[vi2];
            const rI = layerInnerRadius(layer);
            const rO = layerOuterRadius(layer);

            // 6 corners slightly expanded outward for visibility
            const expand = 1.002;
            const verts = [
                ...scale(d0, rI * expand), ...scale(d1, rI * expand), ...scale(d2, rI * expand),
                ...scale(d0, rO * expand), ...scale(d1, rO * expand), ...scale(d2, rO * expand),
            ];
            const lineIndices = [
                0,1, 1,2, 2,0,  // inner triangle
                3,4, 4,5, 5,3,  // outer triangle
                0,3, 1,4, 2,5   // vertical edges
            ];

            gl.useProgram(hlProgram);
            gl.uniformMatrix4fv(hlUniforms.projection, false, projMat);
            gl.uniformMatrix4fv(hlUniforms.view, false, viewMat);

            gl.bindVertexArray(hlVao);
            gl.bindBuffer(gl.ARRAY_BUFFER, hlPosBuf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.DYNAMIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, hlIdxBuf);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(lineIndices), gl.DYNAMIC_DRAW);

            gl.disable(gl.DEPTH_TEST);
            gl.drawElements(gl.LINES, lineIndices.length, gl.UNSIGNED_SHORT, 0);
            gl.enable(gl.DEPTH_TEST);
        }

        // ===== RAYCASTING =====
        function raycastBlock(origin, direction, maxDist, topo, worldBlocks, findFace) {
            const STEP = 0.5;
            let lastFace = -1, lastLayer = -1;

            for (let t = 0.5; t < maxDist; t += STEP) {
                const px = origin[0] + direction[0] * t;
                const py = origin[1] + direction[1] * t;
                const pz = origin[2] + direction[2] * t;
                const dist = Math.sqrt(px*px + py*py + pz*pz);

                const layer = Math.floor((dist - INNER_RADIUS) / BLOCK_HEIGHT);
                if (layer < 0 || layer >= NUM_LAYERS) {
                    lastFace = -1; lastLayer = -1;
                    continue;
                }

                const il = 1/dist;
                const face = findFace([px*il, py*il, pz*il]);

                const block = getBlock(worldBlocks, face, layer);
                if (block !== BLOCK_AIR && block !== BLOCK_WATER) {
                    return {
                        hitFace: face, hitLayer: layer, hitBlock: block,
                        placeFace: lastFace, placeLayer: lastLayer
                    };
                }
                lastFace = face;
                lastLayer = layer;
            }
            return null;
        }

        // ===== PLAYER SPHERE (for multiplayer) =====
        function generatePlayerSphere(segments) {
            const vertices = [], normals = [], indices = [];
            for (let lat = 0; lat <= segments; lat++) {
                const theta = lat * Math.PI / segments;
                const sinT = Math.sin(theta), cosT = Math.cos(theta);
                for (let lon = 0; lon <= segments; lon++) {
                    const phi = lon * 2 * Math.PI / segments;
                    const x = Math.cos(phi)*sinT, y = cosT, z = Math.sin(phi)*sinT;
                    vertices.push(x,y,z); normals.push(x,y,z);
                }
            }
            for (let lat = 0; lat < segments; lat++)
                for (let lon = 0; lon < segments; lon++) {
                    const f = lat*(segments+1)+lon, s = f+segments+1;
                    indices.push(f,s,f+1, s,s+1,f+1);
                }
            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), indices: new Uint32Array(indices) };
        }

        const playerSphereMesh = generatePlayerSphere(12);

        // Player sphere VAO
        const playerSphereVao = gl.createVertexArray();
        gl.bindVertexArray(playerSphereVao);
        const psBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, psBuf);
        gl.bufferData(gl.ARRAY_BUFFER, playerSphereMesh.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);
        const psNBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, psNBuf);
        gl.bufferData(gl.ARRAY_BUFFER, playerSphereMesh.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);
        const psCBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, psCBuf);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);
        const psIBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, psIBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, playerSphereMesh.indices, gl.STATIC_DRAW);

        // Pointer mesh
        function generatePointerCylinder(radius, len, segments) {
            const vertices = [], normals = [], indices = [];
            for (let i = 0; i <= segments; i++) {
                const a = (i/segments)*Math.PI*2, c = Math.cos(a), s = Math.sin(a);
                vertices.push(c*radius,s*radius,0); normals.push(c,s,0);
                vertices.push(c*radius,s*radius,len); normals.push(c,s,0);
            }
            for (let i = 0; i < segments; i++) {
                const i0=i*2,i1=i*2+1,i2=i*2+2,i3=i*2+3;
                indices.push(i0,i2,i1, i1,i2,i3);
            }
            const ti = vertices.length/3;
            vertices.push(0,0,len+radius*2); normals.push(0,0,1);
            const fs = vertices.length/3;
            for (let i = 0; i <= segments; i++) {
                const a=(i/segments)*Math.PI*2;
                vertices.push(Math.cos(a)*radius,Math.sin(a)*radius,len);
                normals.push(Math.cos(a)*0.7,Math.sin(a)*0.7,0.7);
            }
            for (let i = 0; i < segments; i++) indices.push(ti,fs+i+1,fs+i);
            return { vertices: new Float32Array(vertices), normals: new Float32Array(normals), indices: new Uint32Array(indices) };
        }
        const pointerMesh = generatePointerCylinder(0.15, 1.2, 8);
        const pointerVao = gl.createVertexArray();
        gl.bindVertexArray(pointerVao);
        const ptPBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ptPBuf);
        gl.bufferData(gl.ARRAY_BUFFER, pointerMesh.vertices, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.position);
        gl.vertexAttribPointer(attribs.position, 3, gl.FLOAT, false, 0, 0);
        const ptNBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ptNBuf);
        gl.bufferData(gl.ARRAY_BUFFER, pointerMesh.normals, gl.STATIC_DRAW);
        gl.enableVertexAttribArray(attribs.normal);
        gl.vertexAttribPointer(attribs.normal, 3, gl.FLOAT, false, 0, 0);
        const ptCBuf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, ptCBuf);
        gl.enableVertexAttribArray(attribs.color);
        gl.vertexAttribPointer(attribs.color, 3, gl.FLOAT, false, 0, 0);
        const ptIBuf = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ptIBuf);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, pointerMesh.indices, gl.STATIC_DRAW);

        // ===== MULTIPLAYER =====
        const otherPlayers = new Map();
        let myPlayerId = null, myPlayerColor = null, ws = null;
        const PLAYER_SPHERE_RADIUS = 1.0;

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${window.location.host}`);
            ws.onopen = () => console.log('Connected to server');
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                switch (data.type) {
                    case 'init':
                        myPlayerId = data.id;
                        myPlayerColor = data.color;
                        break;
                    case 'playerJoin':
                        otherPlayers.set(data.id, {
                            id: data.id, color: data.color,
                            position: data.position, forward: data.forward, pitch: data.pitch || 0
                        });
                        break;
                    case 'playerMove': {
                        const op = otherPlayers.get(data.id);
                        if (op) { op.position = data.position; op.forward = data.forward; op.pitch = data.pitch || 0; }
                        break;
                    }
                    case 'playerLeave':
                        otherPlayers.delete(data.id);
                        break;
                    case 'blockChange':
                        if (gameState) {
                            setBlock(gameState.worldBlocks, data.face, data.layer, data.block);
                            markChunkDirty(data.face);
                        }
                        break;
                    case 'worldState':
                        if (gameState && data.changes) {
                            for (const c of data.changes) {
                                setBlock(gameState.worldBlocks, c.face, c.layer, c.block);
                                markChunkDirty(c.face);
                            }
                        }
                        break;
                }
            };
            ws.onclose = () => setTimeout(connectWebSocket, 2000);
            ws.onerror = () => {};
        }

        let lastPositionSent = 0;
        function sendPositionUpdate(player) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const now = performance.now();
                if (now - lastPositionSent > 50) {
                    ws.send(JSON.stringify({ type: 'position', position: player.position, forward: player.forward, pitch: player.pitch }));
                    lastPositionSent = now;
                }
            }
        }
        function sendBlockChange(face, layer, block) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'blockChange', face, layer, block }));
            }
        }
        connectWebSocket();

        // ===== PLAYER STATE =====
        const player = {
            position: [0, PLANET_RADIUS + PLAYER_HEIGHT + 10, 0],
            velocity: [0, 0, 0],
            forward: [0, 0, -1],
            pitch: 0,
            grounded: false
        };

        let selectedBlockType = BLOCK_GRASS;

        // Quaternion utilities
        function quatFromAxisAngle(axis, angle) {
            const s = Math.sin(angle/2);
            return [axis[0]*s, axis[1]*s, axis[2]*s, Math.cos(angle/2)];
        }
        function quatRotateVector(q, v) {
            const qv = [q[0],q[1],q[2]];
            const uv = cross(qv,v);
            const uuv = cross(qv,uv);
            return [v[0]+2*(q[3]*uv[0]+uuv[0]), v[1]+2*(q[3]*uv[1]+uuv[1]), v[2]+2*(q[3]*uv[2]+uuv[2])];
        }

        // ===== INPUT =====
        const keys = {};
        let mouseLocked = false;

        const touchState = {
            move: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, touchId: null },
            look: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, touchId: null },
            jump: false, doBreak: false, doPlace: false
        };

        function areTouchControlsVisible() {
            const tc = document.getElementById('touchControls');
            return tc && window.getComputedStyle(tc).display !== 'none';
        }

        const moveTrackpad = document.getElementById('moveTrackpad');
        const lookTrackpad = document.getElementById('lookTrackpad');
        const moveThumb = document.getElementById('moveThumb');
        const lookThumb = document.getElementById('lookThumb');
        const jumpButton = document.getElementById('jumpButton');
        const breakButton = document.getElementById('breakButton');
        const placeButton = document.getElementById('placeButton');
        const TRACKPAD_RADIUS = 60, THUMB_MAX_OFFSET = 35;

        function updateThumbPosition(thumb, ox, oy) {
            if (!thumb) return;
            const cx = Math.max(-THUMB_MAX_OFFSET, Math.min(THUMB_MAX_OFFSET, ox));
            const cy = Math.max(-THUMB_MAX_OFFSET, Math.min(THUMB_MAX_OFFSET, oy));
            thumb.style.transform = `translate(calc(-50% + ${cx}px), calc(-50% + ${cy}px))`;
        }
        function resetThumbPosition(thumb) { if (thumb) thumb.style.transform = 'translate(-50%, -50%)'; }

        function applyLookDelta(yawDelta, pitchDelta) {
            const up = normalize(player.position);
            const cosYaw = Math.cos(yawDelta), sinYaw = Math.sin(yawDelta);
            let forward = player.forward;
            const fdu = dot(forward, up);
            forward = subtract(forward, scale(up, fdu));
            if (length(forward) > 0.001) {
                forward = normalize(forward);
                player.forward = normalize(add(scale(forward, cosYaw), scale(cross(up, forward), sinYaw)));
            }
            player.pitch += pitchDelta;
            player.pitch = Math.max(-Math.PI/2+0.1, Math.min(Math.PI/2-0.1, player.pitch));
        }

        // Touch trackpad handlers
        if (moveTrackpad) {
            moveTrackpad.addEventListener('touchstart', e => {
                e.preventDefault();
                const t = e.changedTouches[0];
                touchState.move.active = true; touchState.move.touchId = t.identifier;
                touchState.move.startX = t.clientX; touchState.move.startY = t.clientY;
                touchState.move.currentX = t.clientX; touchState.move.currentY = t.clientY;
            }, {passive:false});
            moveTrackpad.addEventListener('touchmove', e => {
                e.preventDefault();
                for (const t of e.changedTouches) if (t.identifier === touchState.move.touchId) {
                    touchState.move.currentX = t.clientX; touchState.move.currentY = t.clientY;
                    updateThumbPosition(moveThumb, touchState.move.currentX-touchState.move.startX, touchState.move.currentY-touchState.move.startY);
                }
            }, {passive:false});
            moveTrackpad.addEventListener('touchend', e => {
                for (const t of e.changedTouches) if (t.identifier === touchState.move.touchId) {
                    touchState.move.active = false; touchState.move.touchId = null; resetThumbPosition(moveThumb);
                }
            });
            moveTrackpad.addEventListener('touchcancel', () => { touchState.move.active = false; touchState.move.touchId = null; resetThumbPosition(moveThumb); });
            moveTrackpad.addEventListener('mousedown', e => {
                e.preventDefault(); touchState.move.active = true; touchState.move.touchId = 'mouse';
                touchState.move.startX = e.clientX; touchState.move.startY = e.clientY;
                touchState.move.currentX = e.clientX; touchState.move.currentY = e.clientY;
            });
        }
        if (lookTrackpad) {
            lookTrackpad.addEventListener('touchstart', e => {
                if (e.target === jumpButton || jumpButton?.contains(e.target)) return;
                if (e.target === breakButton || breakButton?.contains(e.target)) return;
                if (e.target === placeButton || placeButton?.contains(e.target)) return;
                e.preventDefault();
                const t = e.changedTouches[0];
                touchState.look.active = true; touchState.look.touchId = t.identifier;
                touchState.look.startX = t.clientX; touchState.look.startY = t.clientY;
                touchState.look.currentX = t.clientX; touchState.look.currentY = t.clientY;
            }, {passive:false});
            lookTrackpad.addEventListener('touchmove', e => {
                e.preventDefault();
                for (const t of e.changedTouches) if (t.identifier === touchState.look.touchId) {
                    const dx = t.clientX - touchState.look.currentX;
                    const dy = t.clientY - touchState.look.currentY;
                    touchState.look.currentX = t.clientX; touchState.look.currentY = t.clientY;
                    applyLookDelta(-dx*0.004, dy*0.004);
                    updateThumbPosition(lookThumb, (touchState.look.currentX-touchState.look.startX)*0.3, (touchState.look.currentY-touchState.look.startY)*0.3);
                }
            }, {passive:false});
            lookTrackpad.addEventListener('touchend', e => {
                for (const t of e.changedTouches) if (t.identifier === touchState.look.touchId) {
                    touchState.look.active = false; touchState.look.touchId = null; resetThumbPosition(lookThumb);
                }
            });
            lookTrackpad.addEventListener('touchcancel', () => { touchState.look.active = false; touchState.look.touchId = null; resetThumbPosition(lookThumb); });
            lookTrackpad.addEventListener('mousedown', e => {
                if (e.target === jumpButton || jumpButton?.contains(e.target)) return;
                e.preventDefault(); touchState.look.active = true; touchState.look.touchId = 'mouse';
                touchState.look.startX = e.clientX; touchState.look.startY = e.clientY;
                touchState.look.currentX = e.clientX; touchState.look.currentY = e.clientY;
            });
        }
        document.addEventListener('mousemove', e => {
            if (touchState.move.active && touchState.move.touchId === 'mouse') {
                touchState.move.currentX = e.clientX; touchState.move.currentY = e.clientY;
                updateThumbPosition(moveThumb, touchState.move.currentX-touchState.move.startX, touchState.move.currentY-touchState.move.startY);
            }
            if (touchState.look.active && touchState.look.touchId === 'mouse') {
                const dx = e.clientX - touchState.look.currentX, dy = e.clientY - touchState.look.currentY;
                touchState.look.currentX = e.clientX; touchState.look.currentY = e.clientY;
                applyLookDelta(-dx*0.004, dy*0.004);
                updateThumbPosition(lookThumb, (touchState.look.currentX-touchState.look.startX)*0.3, (touchState.look.currentY-touchState.look.startY)*0.3);
            }
        });
        document.addEventListener('mouseup', () => {
            if (touchState.move.touchId === 'mouse') { touchState.move.active = false; touchState.move.touchId = null; resetThumbPosition(moveThumb); }
            if (touchState.look.touchId === 'mouse') { touchState.look.active = false; touchState.look.touchId = null; resetThumbPosition(lookThumb); }
        });

        // Jump/break/place buttons
        function setupBtn(btn, prop) {
            if (!btn) return;
            btn.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); touchState[prop] = true; }, {passive:false});
            btn.addEventListener('touchend', () => touchState[prop] = false);
            btn.addEventListener('touchcancel', () => touchState[prop] = false);
            btn.addEventListener('mousedown', e => { e.preventDefault(); e.stopPropagation(); touchState[prop] = true; });
            btn.addEventListener('mouseup', () => touchState[prop] = false);
            btn.addEventListener('mouseleave', () => touchState[prop] = false);
        }
        setupBtn(jumpButton, 'jump');
        setupBtn(breakButton, 'doBreak');
        setupBtn(placeButton, 'doPlace');

        function getMovementInput() {
            let mx = 0, my = 0;
            if (!areTouchControlsVisible()) {
                if (keys['KeyW']) my += 1; if (keys['KeyS']) my -= 1;
                if (keys['KeyD']) mx += 1; if (keys['KeyA']) mx -= 1;
            }
            if (touchState.move.active) {
                const dx = touchState.move.currentX - touchState.move.startX;
                const dy = touchState.move.currentY - touchState.move.startY;
                const dz = 10, maxD = 50;
                if (Math.abs(dx) > dz) mx += Math.max(-1, Math.min(1, (dx-Math.sign(dx)*dz)/maxD));
                if (Math.abs(dy) > dz) my -= Math.max(-1, Math.min(1, (dy-Math.sign(dy)*dz)/maxD));
            }
            return { x: Math.max(-1, Math.min(1, mx)), y: Math.max(-1, Math.min(1, my)) };
        }
        function isJumpPressed() {
            return (!areTouchControlsVisible() && keys['Space']) || touchState.jump;
        }

        document.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
            // Block selection 1-7
            const num = parseInt(e.key);
            if (num >= 1 && num <= 7) {
                selectedBlockType = num;
                updateHotbar();
            }
        });
        document.addEventListener('keyup', e => keys[e.code] = false);

        document.addEventListener('mousemove', e => {
            if (mouseLocked && !areTouchControlsVisible()) {
                applyLookDelta(-e.movementX * 0.002, e.movementY * 0.002);
            }
        });

        const instructions = document.getElementById('instructions');
        canvas.addEventListener('click', () => {
            if (!areTouchControlsVisible()) canvas.requestPointerLock();
        });
        document.addEventListener('pointerlockchange', () => {
            mouseLocked = document.pointerLockElement === canvas;
            instructions.classList.toggle('hidden', mouseLocked);
        });
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Block break/place via mouse
        let lastBreakTime = 0, lastPlaceTime = 0;
        canvas.addEventListener('mousedown', e => {
            if (!mouseLocked || !gameState) return;
            const now = performance.now();
            if (e.button === 0 && now - lastBreakTime > 200) {
                lastBreakTime = now;
                doBreakBlock();
            } else if (e.button === 2 && now - lastPlaceTime > 200) {
                lastPlaceTime = now;
                doPlaceBlock();
            }
        });

        // ===== HOTBAR UI =====
        const hotbarEl = document.getElementById('hotbar');
        function buildHotbar() {
            hotbarEl.innerHTML = '';
            for (let i = 1; i <= 7; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot' + (i === selectedBlockType ? ' selected' : '');
                const preview = document.createElement('div');
                preview.className = 'block-preview';
                const c = BLOCK_COLORS[i];
                preview.style.background = `rgb(${Math.floor(c[0]*255)},${Math.floor(c[1]*255)},${Math.floor(c[2]*255)})`;
                const hint = document.createElement('span');
                hint.className = 'key-hint';
                hint.textContent = i;
                slot.appendChild(hint);
                slot.appendChild(preview);
                hotbarEl.appendChild(slot);
            }
        }
        function updateHotbar() {
            const slots = hotbarEl.querySelectorAll('.hotbar-slot');
            slots.forEach((s, i) => s.classList.toggle('selected', i + 1 === selectedBlockType));
            document.getElementById('blockName').textContent = BLOCK_NAMES[selectedBlockType];
        }
        buildHotbar();

        // ===== GAME STATE (set after async init) =====
        let gameState = null;

        function markChunkDirty(faceIdx) {
            if (!gameState) return;
            const chunkIdx = gameState.topo.faceToChunk[faceIdx];
            gameState.chunks[chunkIdx].dirty = true;
            // Also dirty neighbor chunks if face is on boundary
            const topo = gameState.topo;
            for (let e = 0; e < 3; e++) {
                const nf = topo.faceNeighbors[faceIdx * 3 + e];
                if (nf >= 0) {
                    const nc = topo.faceToChunk[nf];
                    if (nc !== chunkIdx) gameState.chunks[nc].dirty = true;
                }
            }
        }

        function getLookDirection() {
            const up = normalize(player.position);
            let forward = player.forward;
            forward = subtract(forward, scale(up, dot(forward, up)));
            forward = normalize(forward);
            const cosPitch = Math.cos(-player.pitch), sinPitch = Math.sin(-player.pitch);
            return normalize([
                forward[0]*cosPitch + up[0]*sinPitch,
                forward[1]*cosPitch + up[1]*sinPitch,
                forward[2]*cosPitch + up[2]*sinPitch
            ]);
        }

        function doBreakBlock() {
            if (!gameState) return;
            const dir = getLookDirection();
            const hit = raycastBlock(player.position, dir, 20, gameState.topo, gameState.worldBlocks, gameState.findFace);
            if (hit) {
                setBlock(gameState.worldBlocks, hit.hitFace, hit.hitLayer, BLOCK_AIR);
                markChunkDirty(hit.hitFace);
                sendBlockChange(hit.hitFace, hit.hitLayer, BLOCK_AIR);
            }
        }
        function doPlaceBlock() {
            if (!gameState) return;
            const dir = getLookDirection();
            const hit = raycastBlock(player.position, dir, 20, gameState.topo, gameState.worldBlocks, gameState.findFace);
            if (hit && hit.placeFace >= 0 && hit.placeLayer >= 0) {
                // Don't place inside player
                const placeR = layerOuterRadius(hit.placeLayer);
                const playerR = length(player.position);
                if (Math.abs(placeR - playerR) < PLAYER_HEIGHT * 1.5) {
                    const pDir = normalize(player.position);
                    const pFace = gameState.findFace(pDir);
                    if (pFace === hit.placeFace) return;
                }
                setBlock(gameState.worldBlocks, hit.placeFace, hit.placeLayer, selectedBlockType);
                markChunkDirty(hit.placeFace);
                sendBlockChange(hit.placeFace, hit.placeLayer, selectedBlockType);
            }
        }

        // ===== PHYSICS =====
        function getTerrainHeight(pos, topo, worldBlocks, findFace) {
            const dir = normalize(pos);
            const face = findFace(dir);
            for (let l = NUM_LAYERS - 1; l >= 0; l--) {
                const b = getBlock(worldBlocks, face, l);
                if (b !== BLOCK_AIR && b !== BLOCK_WATER) return layerOuterRadius(l);
            }
            return INNER_RADIUS;
        }

        function updatePhysics(dt) {
            if (!gameState) return;
            const up = normalize(player.position);
            let forward = player.forward;
            const fdu = dot(forward, up);
            forward = subtract(forward, scale(up, fdu));
            if (length(forward) < 0.001) {
                forward = Math.abs(up[1]) < 0.9 ? [0,1,0] : [1,0,0];
                forward = subtract(forward, scale(up, dot(forward, up)));
            }
            forward = normalize(forward);
            player.forward = forward;

            const right = normalize(cross(forward, up));
            const moveInput = getMovementInput();
            let moveDir = [0,0,0];
            if (moveInput.y !== 0) moveDir = add(moveDir, scale(forward, moveInput.y));
            if (moveInput.x !== 0) moveDir = add(moveDir, scale(right, moveInput.x));

            if (length(moveDir) > 0) {
                moveDir = normalize(moveDir);
                const verticalVel = scale(up, dot(player.velocity, up));
                player.velocity = add(verticalVel, scale(moveDir, MOVE_SPEED));
            } else {
                const verticalVel = scale(up, dot(player.velocity, up));
                const horizontalVel = subtract(player.velocity, verticalVel);
                player.velocity = add(verticalVel, scale(horizontalVel, 0.9));
            }

            if (isJumpPressed() && player.grounded) {
                player.velocity = add(player.velocity, scale(up, JUMP_VELOCITY));
                player.grounded = false;
            }

            player.velocity = add(player.velocity, scale(up, -GRAVITY * dt));

            const oldUp = up;
            player.position = add(player.position, scale(player.velocity, dt));

            // Ground collision
            const newDist = length(player.position);
            const newUp = normalize(player.position);
            const groundHeight = getTerrainHeight(player.position, gameState.topo, gameState.worldBlocks, gameState.findFace);

            if (newDist < groundHeight + PLAYER_HEIGHT) {
                player.position = scale(newUp, groundHeight + PLAYER_HEIGHT);
                const velDown = dot(player.velocity, scale(newUp, -1));
                if (velDown > 0) player.velocity = add(player.velocity, scale(newUp, velDown));
                player.grounded = true;
            } else {
                player.grounded = false;
            }

            // Ceiling collision
            const headDist = length(player.position) + PLAYER_HEIGHT * 0.5;
            const headLayer = Math.floor((headDist - INNER_RADIUS) / BLOCK_HEIGHT);
            if (headLayer >= 0 && headLayer < NUM_LAYERS) {
                const headFace = gameState.findFace(newUp);
                if (getBlock(gameState.worldBlocks, headFace, headLayer) !== BLOCK_AIR &&
                    getBlock(gameState.worldBlocks, headFace, headLayer) !== BLOCK_WATER) {
                    const ceilH = layerInnerRadius(headLayer) - PLAYER_HEIGHT * 0.5;
                    player.position = scale(newUp, ceilH);
                    const upVel = dot(player.velocity, newUp);
                    if (upVel > 0) player.velocity = subtract(player.velocity, scale(newUp, upVel));
                }
            }

            // Rotate forward to stay tangent
            const rotAxis = cross(oldUp, newUp);
            const rotLen = length(rotAxis);
            if (rotLen > 0.0001) {
                const angle = Math.asin(Math.min(1, rotLen));
                const axis = scale(rotAxis, 1/rotLen);
                const q = quatFromAxisAngle(axis, angle);
                player.forward = normalize(quatRotateVector(q, player.forward));
            }

            // Touch break/place
            if (touchState.doBreak) { touchState.doBreak = false; doBreakBlock(); }
            if (touchState.doPlace) { touchState.doPlace = false; doPlaceBlock(); }
        }

        // ===== CAMERA =====
        function getCameraMatrix() {
            const up = normalize(player.position);
            let forward = player.forward;
            forward = subtract(forward, scale(up, dot(forward, up)));
            forward = normalize(forward);
            const right = normalize(cross(forward, up));
            const cp = Math.cos(-player.pitch), sp = Math.sin(-player.pitch);
            const lookFwd = normalize([forward[0]*cp+up[0]*sp, forward[1]*cp+up[1]*sp, forward[2]*cp+up[2]*sp]);
            const camUp = normalize(cross(right, lookFwd));
            return mat4LookAt(player.position, add(player.position, lookFwd), camUp);
        }

        // ===== MULTIPLAYER RENDERING HELPERS =====
        function createColorArray(color, count) {
            const c = new Float32Array(count * 3);
            for (let i = 0; i < count; i++) { c[i*3] = color.r; c[i*3+1] = color.g; c[i*3+2] = color.b; }
            return c;
        }
        function mat4FromLookDirection(fwd, up) {
            const f = normalize(fwd), r = normalize(cross(f, up)), u = normalize(cross(r, f));
            return new Float32Array([r[0],r[1],r[2],0, u[0],u[1],u[2],0, f[0],f[1],f[2],0, 0,0,0,1]);
        }
        function applyPitchToForward(fwd, up, pitch) {
            const cp = Math.cos(-pitch), sp = Math.sin(-pitch);
            return normalize([fwd[0]*cp+up[0]*sp, fwd[1]*cp+up[1]*sp, fwd[2]*cp+up[2]*sp]);
        }
        function projectToScreen(wp, vm, pm) {
            let vp = [vm[0]*wp[0]+vm[4]*wp[1]+vm[8]*wp[2]+vm[12], vm[1]*wp[0]+vm[5]*wp[1]+vm[9]*wp[2]+vm[13], vm[2]*wp[0]+vm[6]*wp[1]+vm[10]*wp[2]+vm[14], vm[3]*wp[0]+vm[7]*wp[1]+vm[11]*wp[2]+vm[15]];
            let cp = [pm[0]*vp[0]+pm[4]*vp[1]+pm[8]*vp[2]+pm[12]*vp[3], pm[1]*vp[0]+pm[5]*vp[1]+pm[9]*vp[2]+pm[13]*vp[3], pm[2]*vp[0]+pm[6]*vp[1]+pm[10]*vp[2]+pm[14]*vp[3], pm[3]*vp[0]+pm[7]*vp[1]+pm[11]*vp[2]+pm[14+1]*vp[3]];
            if (cp[3] <= 0) return null;
            const nx = cp[0]/cp[3], ny = cp[1]/cp[3], nz = cp[2]/cp[3];
            if (nx<-1||nx>1||ny<-1||ny>1||nz<-1||nz>1) return null;
            return { x: (nx+1)*0.5*canvas.width, y: (1-ny)*0.5*canvas.height, depth: nz };
        }
        function drawNametag(id, sp, color) {
            const sid = id.substring(0, 8);
            ctx.font = 'bold 14px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
            const tw = ctx.measureText(sid).width;
            ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(sp.x-tw/2-4, sp.y-20, tw+8, 18);
            ctx.fillStyle = `rgb(${Math.floor(color.r*255)},${Math.floor(color.g*255)},${Math.floor(color.b*255)})`;
            ctx.fillText(sid, sp.x, sp.y-5);
        }

        // ===== UI =====
        const posEl = document.getElementById('pos');
        const latEl = document.getElementById('lat');
        const lonEl = document.getElementById('lon');
        const groundedEl = document.getElementById('grounded');

        // ===== ASYNC INITIALIZATION =====
        async function initGame() {
            const loadingEl = document.getElementById('loading');
            const fillEl = document.getElementById('loadingFill');
            const textEl = document.getElementById('loadingText');

            textEl.textContent = 'Building topology...';
            await new Promise(r => setTimeout(r, 10));

            const topo = buildIcosphereTopology(SUBDIVISIONS);
            console.log(`Topology: ${topo.faceCount} faces, ${topo.vertexCount} vertices, ${topo.chunkCount} chunks`);

            fillEl.style.width = '15%';
            textEl.textContent = 'Building face lookup...';
            await new Promise(r => setTimeout(r, 10));

            const findFace = buildFaceLookup(topo);

            fillEl.style.width = '25%';
            textEl.textContent = 'Generating terrain...';
            await new Promise(r => setTimeout(r, 10));

            const worldBlocks = new Uint8Array(topo.faceCount * NUM_LAYERS);
            generateTerrain(topo, worldBlocks);

            fillEl.style.width = '35%';
            textEl.textContent = 'Building chunks...';
            await new Promise(r => setTimeout(r, 10));

            // Create chunks
            const chunks = new Array(topo.chunkCount);
            for (let c = 0; c < topo.chunkCount; c++) {
                chunks[c] = {
                    id: c,
                    faceIndices: topo.chunkFaces[c],
                    center: [topo.chunkCenters[c*3], topo.chunkCenters[c*3+1], topo.chunkCenters[c*3+2]],
                    dirty: true, vao: null, posBuf: null, normBuf: null, colorBuf: null, idxBuf: null, indexCount: 0
                };
            }

            // Build all chunk meshes progressively
            const batchSize = 20;
            for (let i = 0; i < chunks.length; i += batchSize) {
                for (let j = i; j < Math.min(i + batchSize, chunks.length); j++) {
                    buildChunkMesh(chunks[j], topo, worldBlocks);
                }
                const pct = 35 + (i / chunks.length) * 60;
                fillEl.style.width = pct + '%';
                textEl.textContent = `Building chunks... ${Math.min(i+batchSize, chunks.length)}/${chunks.length}`;
                await new Promise(r => setTimeout(r, 0));
            }

            // Spawn player above terrain
            const spawnDir = normalize([0, 1, 0]);
            const spawnFace = findFace(spawnDir);
            let spawnHeight = PLANET_RADIUS;
            for (let l = NUM_LAYERS - 1; l >= 0; l--) {
                if (getBlock(worldBlocks, spawnFace, l) !== BLOCK_AIR && getBlock(worldBlocks, spawnFace, l) !== BLOCK_WATER) {
                    spawnHeight = layerOuterRadius(l);
                    break;
                }
            }
            player.position = scale(spawnDir, spawnHeight + PLAYER_HEIGHT);

            initHighlight();

            fillEl.style.width = '100%';
            textEl.textContent = 'Ready!';
            await new Promise(r => setTimeout(r, 300));
            loadingEl.style.display = 'none';

            gameState = { topo, worldBlocks, findFace, chunks };

            // Start render loop
            requestAnimationFrame(render);
        }

        // ===== RENDER LOOP =====
        let lastTime = performance.now();

        function getVisibleChunks() {
            const dir = normalize(player.position);
            const visible = [];
            for (let i = 0; i < gameState.chunks.length; i++) {
                const c = gameState.chunks[i].center;
                const d = dir[0]*c[0] + dir[1]*c[1] + dir[2]*c[2];
                if (d > VIEW_ANGLE_COS) visible.push(gameState.chunks[i]);
            }
            return visible;
        }

        function render(time) {
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            updatePhysics(dt);
            sendPositionUpdate(player);

            // Rebuild dirty chunks
            let rebuilds = 0;
            for (const chunk of gameState.chunks) {
                if (chunk.dirty && rebuilds < 4) {
                    buildChunkMesh(chunk, gameState.topo, gameState.worldBlocks);
                    rebuilds++;
                }
            }

            // Update UI
            const p = player.position;
            posEl.textContent = `${p[0].toFixed(1)}, ${p[1].toFixed(1)}, ${p[2].toFixed(1)}`;
            const np = normalize(p);
            latEl.textContent = (Math.asin(np[1]) * 180 / Math.PI).toFixed(1);
            lonEl.textContent = (Math.atan2(np[0], np[2]) * 180 / Math.PI).toFixed(1);
            groundedEl.textContent = player.grounded ? 'Yes' : 'No';

            // Clear
            gl.clearColor(0.5, 0.7, 0.9, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            ctx.clearRect(0, 0, labelCanvas.width, labelCanvas.height);

            gl.useProgram(program);
            const projection = mat4Perspective(Math.PI / 3, canvas.width / canvas.height, 0.1, 1000);
            const view = getCameraMatrix();
            const model = mat4Identity();
            gl.uniformMatrix4fv(uniforms.projection, false, projection);
            gl.uniformMatrix4fv(uniforms.view, false, view);
            gl.uniformMatrix4fv(uniforms.model, false, model);
            gl.uniform3f(uniforms.lightDir, 0.5, 1, 0.3);
            gl.uniform3fv(uniforms.cameraPos, player.position);

            // Draw visible chunks
            const visibleChunks = getVisibleChunks();
            for (const chunk of visibleChunks) {
                if (chunk.indexCount > 0 && chunk.vao) {
                    gl.bindVertexArray(chunk.vao);
                    gl.drawElements(gl.TRIANGLES, chunk.indexCount, gl.UNSIGNED_INT, 0);
                }
            }

            // Block highlight
            const lookDir = getLookDirection();
            const hit = raycastBlock(player.position, lookDir, 20, gameState.topo, gameState.worldBlocks, gameState.findFace);
            if (hit) {
                drawBlockHighlight(hit.hitFace, hit.hitLayer, gameState.topo, view, projection);
                gl.useProgram(program); // restore program
                gl.uniformMatrix4fv(uniforms.projection, false, projection);
                gl.uniformMatrix4fv(uniforms.view, false, view);
                gl.uniformMatrix4fv(uniforms.model, false, model);
                gl.uniform3f(uniforms.lightDir, 0.5, 1, 0.3);
                gl.uniform3fv(uniforms.cameraPos, player.position);
            }

            // Draw other players
            const vertexCount = playerSphereMesh.vertices.length / 3;
            const pointerVertCount = pointerMesh.vertices.length / 3;
            otherPlayers.forEach(op => {
                const ca = createColorArray(op.color, vertexCount);
                gl.bindBuffer(gl.ARRAY_BUFFER, psCBuf);
                gl.bufferData(gl.ARRAY_BUFFER, ca, gl.DYNAMIC_DRAW);
                const pos = op.position;
                const tMat = mat4Translate(pos[0], pos[1], pos[2]);
                const sMat = mat4Scale(PLAYER_SPHERE_RADIUS);
                gl.uniformMatrix4fv(uniforms.model, false, mat4Multiply(tMat, sMat));
                gl.bindVertexArray(playerSphereVao);
                gl.drawElements(gl.TRIANGLES, playerSphereMesh.indices.length, gl.UNSIGNED_INT, 0);

                // Pointer
                const pUp = normalize(pos);
                let ld = op.forward || [0,0,-1];
                ld = subtract(ld, scale(pUp, dot(ld, pUp)));
                if (length(ld) < 0.001) ld = [0,0,-1];
                ld = normalize(ld);
                const ld3d = applyPitchToForward(ld, pUp, op.pitch || 0);
                const rm = mat4FromLookDirection(ld3d, pUp);
                const pt = mat4Translate(pos[0], pos[1], pos[2]);
                const pc = { r: op.color.r*0.7, g: op.color.g*0.7, b: op.color.b*0.7 };
                gl.bindVertexArray(pointerVao);
                gl.bindBuffer(gl.ARRAY_BUFFER, ptCBuf);
                gl.bufferData(gl.ARRAY_BUFFER, createColorArray(pc, pointerVertCount), gl.DYNAMIC_DRAW);
                gl.uniformMatrix4fv(uniforms.model, false, mat4Multiply(pt, rm));
                gl.drawElements(gl.TRIANGLES, pointerMesh.indices.length, gl.UNSIGNED_INT, 0);

                // Nametag
                const ntp = [pos[0]+pUp[0]*(PLAYER_SPHERE_RADIUS+1.5), pos[1]+pUp[1]*(PLAYER_SPHERE_RADIUS+1.5), pos[2]+pUp[2]*(PLAYER_SPHERE_RADIUS+1.5)];
                const sp = projectToScreen(ntp, view, projection);
                if (sp) drawNametag(op.id, sp, op.color);
            });

            document.getElementById('playerCount').textContent = otherPlayers.size + 1;
            gl.uniformMatrix4fv(uniforms.model, false, model);

            requestAnimationFrame(render);
        }

        // Start the game
        initGame();
    </script>
</body>
</html>
